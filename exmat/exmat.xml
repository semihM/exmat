<?xml version="1.0"?>
<doc>
    <assembly>
        <name>exmat</name>
    </assembly>
    <members>
        <member name="T:ExMat.Attributes.ExNativeFuncBase">
            <summary>
            Attribute to register a method as a non-delegate native function
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExNativeFuncBase.Name">
            <summary>
            Function name
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExNativeFuncBase.NumberOfParameters">
            <summary>
            Argument requirement information
            <para>If this value is not <see cref="F:System.Int32.MaxValue"/>, <see cref="T:ExMat.Attributes.ExNativeParamBase"/> attributes will be ignored</para>
            <para>To use vargs, set this to -1</para>
            <para>To use vargs with x amount of parameters, set this to (-1 - x)</para>
            <para>Positive 'n': n - 1 parameters == n - 1 arguments</para>
            <para>Negative 'n': -n parameters == -n - 1 arguments minimum</para>
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExNativeFuncBase.Description">
            <summary>
            Documentation
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExNativeFuncBase.BaseTypeMask">
            <summary>
            Base object type, '.' for native functions, other characters for delegates
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExNativeFuncBase.Returns">
            <summary>
            Return type
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExNativeFuncBase.IsDelegateFunction">
            <summary>
            Is this a delegate function? Works with <see cref="F:ExMat.Attributes.ExNativeFuncBase.BaseTypeMask"/> to decide which object type's delegate it will be
            </summary>
        </member>
        <member name="M:ExMat.Attributes.ExNativeFuncBase.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:ExMat.Attributes.ExNativeFuncBase.#ctor(System.String,ExMat.ExBaseType,System.String)">
            <summary>
            Native function named <paramref name="name"/>, returning <paramref name="returns"/>, described as <paramref name="docs"/>, with <see cref="F:ExMat.Attributes.ExNativeFuncBase.BaseTypeMask"/> = <c>'.'</c>
            </summary>
            <param name="name">Function name</param>
            <param name="returns">Return type</param>
            <param name="docs">Documentation</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeFuncBase.#ctor(System.String,System.String)">
            <summary>
            Native function named <paramref name="name"/>, returning <see cref="F:ExMat.ExObjType.NULL"/>, described as <paramref name="docs"/>, with <see cref="F:ExMat.Attributes.ExNativeFuncBase.BaseTypeMask"/> = <c>'.'</c>
            </summary>
            <param name="name">Function name</param>
            <param name="docs">Documentation</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeFuncBase.#ctor(System.String,ExMat.ExBaseType,System.String,System.Int32)">
            <summary>
            Native function named <paramref name="name"/>, returning <paramref name="returns"/>, described as <paramref name="docs"/>, with <see cref="F:ExMat.Attributes.ExNativeFuncBase.BaseTypeMask"/> = <c>'.'</c>
            </summary>
            <param name="name">Function name</param>
            <param name="returns">Return type</param>
            <param name="docs">Documentation</param>
            <param name="overwriteParamCount">Sets <see cref="F:ExMat.Attributes.ExNativeFuncBase.NumberOfParameters"/>, see <see cref="F:ExMat.Attributes.ExNativeFuncBase.NumberOfParameters"/> documentation</param>
        </member>
        <member name="T:ExMat.Attributes.ExCommonDelegateType">
            <summary>
            Common delegate native function types, used for template <see cref="M:ExMat.Attributes.ExNativeFuncDelegate.#ctor(ExMat.Attributes.ExCommonDelegateType,System.Char)"/> constructor
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExCommonDelegateType.WEAKREF">
            <summary>
            'weakref' function template
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExCommonDelegateType.LENGTH">
            <summary>
            'len' function template
            </summary>
        </member>
        <member name="T:ExMat.Attributes.ExNativeFuncDelegate">
            <summary>
            Native delegate function attribute
            <para>This attribute makes connects the method to given <see cref="T:ExMat.ExBaseType"/> type objects as a delegate</para>
            </summary>
        </member>
        <member name="M:ExMat.Attributes.ExNativeFuncDelegate.#ctor">
            <summary>
            Initialize <see cref="T:ExMat.Attributes.ExNativeFuncBase"/> as delegate
            </summary>
        </member>
        <member name="M:ExMat.Attributes.ExNativeFuncDelegate.#ctor(System.String,ExMat.ExBaseType,System.String,System.Char)">
            <summary>
            Explicitly define a delegate function
            </summary>
            <param name="name">Name of the native function user will refer this method as</param>
            <param name="returns">What type of values this function can return ?</param>
            <param name="docs">Explanation for this function's purpose</param>
            <param name="basetype">Base object type this function will be a delegate of, refer to <see cref="F:ExMat.ExMat.TypeMasks"/> method</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeFuncDelegate.#ctor(ExMat.Attributes.ExCommonDelegateType,System.Char)">
            <summary>
            Construct delegate  from common delegate types
            </summary>
            <param name="commonDelegateType">Template type</param>
            <param name="basetype">Delegate base type mask</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeFuncDelegate.#ctor(ExMat.Attributes.ExCommonDelegateType,ExMat.ExBaseType)">
            <summary>
            Construct delegate  from common delegate types
            </summary>
            <param name="commonDelegateType">Template type</param>
            <param name="basetype">Delegate base type mask</param>
        </member>
        <member name="T:ExMat.Attributes.ExNativeParamBase">
            <summary>
            Attribute to register a native function parameter
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExNativeParamBase.Index">
            <summary>
            Parameter index
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExNativeParamBase.Name">
            <summary>
            Parameter name
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExNativeParamBase.TypeMask">
            <summary>
            Parameter type mask string. See <see cref="F:ExMat.ExMat.TypeMasks"/>
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExNativeParamBase.Description">
            <summary>
            Parameter information
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExNativeParamBase.DefaultValue">
            <summary>
            Default value if any
            </summary>
        </member>
        <member name="M:ExMat.Attributes.ExNativeParamBase.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:ExMat.Attributes.ExNativeParamBase.#ctor(System.Int32,System.String,System.String,System.String)">
            <summary>
            Parameter no #<paramref name="idx"/>, named <paramref name="name"/>, accepting types <paramref name="typeMask"/>, described as <paramref name="description"/>, no default value
            </summary>
            <param name="idx">Parameter no</param>
            <param name="name">Parameter name</param>
            <param name="typeMask">Parameter type mask, see <see cref="F:ExMat.ExMat.TypeMasks"/> docs</param>
            <param name="description">Parameter description</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeParamBase.#ctor(System.Int32,System.String,System.String,System.String,System.Char)">
            <summary>
            Parameter no #<paramref name="idx"/>, named <paramref name="name"/>, accepting types <paramref name="typeMask"/>, described as <paramref name="description"/>, default value <see cref="F:ExMat.ExObjType.NULL"/>
            <paramref name="nullDefault"/> value doesn't matter!
            </summary>
            <param name="idx">Parameter no</param>
            <param name="name">Parameter name</param>
            <param name="typeMask">Parameter type mask, see <see cref="F:ExMat.ExMat.TypeMasks"/> docsoperator</param>
            <param name="description">Parameter description</param>
            <param name="nullDefault">Any character, <see cref="F:ExMat.ExObjType.NULL"/> is used as default value in any case</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeParamBase.#ctor(System.Int32,System.String,System.String,System.String,System.String)">
            <summary>
            Parameter no #<paramref name="idx"/>, named <paramref name="name"/>, accepting types <paramref name="typeMask"/>, described as <paramref name="description"/>, default value <see cref="F:ExMat.ExObjType.STRING"/> <paramref name="def"/>
            </summary>
            <param name="idx">Parameter no</param>
            <param name="name">Parameter name</param>
            <param name="typeMask">Parameter type mask, see <see cref="F:ExMat.ExMat.TypeMasks"/> docs</param>
            <param name="description">Parameter description</param>
            <param name="def">String default value</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeParamBase.#ctor(System.Int32,System.String,System.String,System.String,System.Int64)">
            <summary>
            Parameter no #<paramref name="idx"/>, named <paramref name="name"/>, accepting types <paramref name="typeMask"/>, described as <paramref name="description"/>, default value <see cref="F:ExMat.ExObjType.INTEGER"/> <paramref name="def"/>
            </summary>
            <param name="idx">Parameter no</param>
            <param name="name">Parameter name</param>
            <param name="typeMask">Parameter type mask, see <see cref="F:ExMat.ExMat.TypeMasks"/> docs</param>
            <param name="description">Parameter description</param>
            <param name="def">Integer default value</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeParamBase.#ctor(System.Int32,System.String,System.String,System.String,System.Double)">
            <summary>
            Parameter no #<paramref name="idx"/>, named <paramref name="name"/>, accepting types <paramref name="typeMask"/>, described as <paramref name="description"/>, default value <see cref="F:ExMat.ExObjType.FLOAT"/> <paramref name="def"/>
            </summary>
            <param name="idx">Parameter no</param>
            <param name="name">Parameter name</param>
            <param name="typeMask">Parameter type mask, see <see cref="F:ExMat.ExMat.TypeMasks"/> docs</param>
            <param name="description">Parameter description</param>
            <param name="def">Float default value</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeParamBase.#ctor(System.Int32,System.String,System.String,System.String,System.Boolean)">
            <summary>
            Parameter no #<paramref name="idx"/>, named <paramref name="name"/>, accepting types <paramref name="typeMask"/>, described as <paramref name="description"/>, default value <see cref="F:ExMat.ExObjType.BOOL"/> <paramref name="def"/>
            </summary>
            <param name="idx">Parameter no</param>
            <param name="name">Parameter name</param>
            <param name="typeMask">Parameter type mask, see <see cref="F:ExMat.ExMat.TypeMasks"/> docs</param>
            <param name="description">Parameter description</param>
            <param name="def">Boolean default value</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeParamBase.#ctor(System.Int32,System.String,ExMat.ExBaseType,System.String)">
            <summary>
            Parameter no #<paramref name="idx"/>, named <paramref name="name"/>, accepting types <paramref name="typeMask"/>, described as <paramref name="description"/>, no default value
            </summary>
            <param name="idx">Parameter no</param>
            <param name="name">Parameter name</param>
            <param name="typeMask">Parameter type mask, allows combinations with <c>|</c> operator</param>
            <param name="description">Parameter description</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeParamBase.#ctor(System.Int32,System.String,ExMat.ExBaseType,System.String,System.Char)">
            <summary>
            Parameter no #<paramref name="idx"/>, named <paramref name="name"/>, accepting types <paramref name="typeMask"/>, described as <paramref name="description"/>, default value <see cref="F:ExMat.ExObjType.NULL"/>
            <paramref name="nullDefault"/> value doesn't matter!
            </summary>
            <param name="idx">Parameter no</param>
            <param name="name">Parameter name</param>
            <param name="typeMask">Parameter type mask, allows combinations with <c>|</c> operator</param>
            <param name="description">Parameter description</param>
            <param name="nullDefault">Any character, <see cref="F:ExMat.ExObjType.NULL"/> is used as default value in any case</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeParamBase.#ctor(System.Int32,System.String,ExMat.ExBaseType,System.String,System.String)">
            <summary>
            Parameter no #<paramref name="idx"/>, named <paramref name="name"/>, accepting types <paramref name="typeMask"/>, described as <paramref name="description"/>, default value <see cref="F:ExMat.ExObjType.STRING"/> <paramref name="def"/>
            </summary>
            <param name="idx">Parameter no</param>
            <param name="name">Parameter name</param>
            <param name="typeMask">Parameter type mask, allows combinations with <c>|</c> operator</param>
            <param name="description">Parameter description</param>
            <param name="def">String default value</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeParamBase.#ctor(System.Int32,System.String,ExMat.ExBaseType,System.String,System.Int64)">
            <summary>
            Parameter no #<paramref name="idx"/>, named <paramref name="name"/>, accepting types <paramref name="typeMask"/>, described as <paramref name="description"/>, default value <see cref="F:ExMat.ExObjType.INTEGER"/> <paramref name="def"/>
            </summary>
            <param name="idx">Parameter no</param>
            <param name="name">Parameter name</param>
            <param name="typeMask">Parameter type mask, allows combinations with <c>|</c> operator</param>
            <param name="description">Parameter description</param>
            <param name="def">Integer default value</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeParamBase.#ctor(System.Int32,System.String,ExMat.ExBaseType,System.String,System.Double)">
            <summary>
            Parameter no #<paramref name="idx"/>, named <paramref name="name"/>, accepting types <paramref name="typeMask"/>, described as <paramref name="description"/>, default value <see cref="F:ExMat.ExObjType.FLOAT"/> <paramref name="def"/>
            </summary>
            <param name="idx">Parameter no</param>
            <param name="name">Parameter name</param>
            <param name="typeMask">Parameter type mask, allows combinations with <c>|</c> operator</param>
            <param name="description">Parameter description</param>
            <param name="def">Float default value</param>
        </member>
        <member name="M:ExMat.Attributes.ExNativeParamBase.#ctor(System.Int32,System.String,ExMat.ExBaseType,System.String,System.Boolean)">
            <summary>
            Parameter no #<paramref name="idx"/>, named <paramref name="name"/>, accepting types <paramref name="typeMask"/>, described as <paramref name="description"/>, default value <see cref="F:ExMat.ExObjType.BOOL"/> <paramref name="def"/>
            </summary>
            <param name="idx">Parameter no</param>
            <param name="name">Parameter name</param>
            <param name="typeMask">Parameter type mask, allows combinations with <c>|</c> operator</param>
            <param name="description">Parameter description</param>
            <param name="def">Boolean default value</param>
        </member>
        <member name="T:ExMat.Attributes.ExStdLibBase">
            <summary>
            Attribute to mark a class as a standard library of given <see cref="T:ExMat.ExStdLibType"/> type
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExStdLibBase.Type">
            <summary>
            Library type
            </summary>
        </member>
        <member name="M:ExMat.Attributes.ExStdLibBase.#ctor(ExMat.ExStdLibType)">
            <summary>
            Constructor for library of type <paramref name="type"/>
            </summary>
            <param name="type">Library type</param>
        </member>
        <member name="T:ExMat.Attributes.ExStdLibConstDict">
            <summary>
            Attribute to register a dictionary property defined in a std lib class
            <para>Dictionary must have <see cref="T:System.String"/> keys and <see cref="T:ExMat.Objects.ExObject"/> values template</para>
            <para>Make sure the constants dictionary is defind as a property.</para>
            <para>Use <see langword="nameof"/> for best practice of getting the property name</para>
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExStdLibConstDict.Name">
            <summary>
            Dictionary name
            </summary>
        </member>
        <member name="M:ExMat.Attributes.ExStdLibConstDict.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:ExMat.Attributes.ExStdLibConstDict.#ctor(System.String)">
            <summary>
            Set name as <paramref name="name"/>
            </summary>
            <param name="name">Dict name</param>
        </member>
        <member name="T:ExMat.Attributes.ExStdLibName">
            <summary>
            Attribute to set the name of a standard library
            <para>This name is used by the users to refer to this library</para>
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExStdLibName.Name">
            <summary>
            Library name
            </summary>
        </member>
        <member name="M:ExMat.Attributes.ExStdLibName.#ctor(System.String)">
            <summary>
            Mark as library with given name
            </summary>
            <param name="name">Library name</param>
        </member>
        <member name="T:ExMat.Attributes.ExStdLibRegister">
            <summary>
            Attribute to register a main registery method of a standard library
            <para>This method is for any extra work that needs to be done for the library's methods</para>
            <para>Registery method must be a property defined as a delegate <see cref="T:ExMat.ExMat.StdLibRegistery"/></para>
            <para>Use <see langword="nameof"/> for best practice of getting the property name</para>
            </summary>
        </member>
        <member name="F:ExMat.Attributes.ExStdLibRegister.RegisterMethodName">
            <summary>
            Method name
            </summary>
        </member>
        <member name="M:ExMat.Attributes.ExStdLibRegister.#ctor(System.String)">
            <summary>
            Look for a property with given name as registery method
            </summary>
            <param name="name">Registery name</param>
        </member>
        <member name="T:ExMat.API.ExApi">
            <summary>
            ExMat API method provider
            </summary>
        </member>
        <member name="M:ExMat.API.ExApi.IsValidStdLibFunction(System.Reflection.MethodInfo)">
            <summary>
            Check wheter given method has the same signature as <see cref="T:ExMat.ExMat.StdLibFunction"/> delegate
            </summary>
            <param name="m">Method to check</param>
            <returns><see langword="true"/> if <paramref name="m"/> has the same signature as <see cref="T:ExMat.ExMat.StdLibFunction"/>, otherwise <see langword="false"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetNonDelegateNativeFunctions(System.Type)">
            <summary>
            Find all methods with <see cref="T:ExMat.Attributes.ExNativeFuncBase"/> attribute an not the <see cref="T:ExMat.Attributes.ExNativeFuncDelegate"/> attribute, in the given type of standard library
            </summary>
            <param name="type">Standard library type</param>
            <returns>List of native non-delegate functions found</returns>
        </member>
        <member name="M:ExMat.API.ExApi.FindDelegateNativeFunctions">
            <summary>
            Find all methods with <see cref="T:ExMat.Attributes.ExNativeFuncDelegate"/> attribute defined in the current assembly
            </summary>
            <returns>List of native delegate functions found in the assembly</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetDelegateNativeFunctions(System.Type)">
            <summary>
            Find all methods with <see cref="T:ExMat.Attributes.ExNativeFuncDelegate"/> attribute in the given type of standard library
            </summary>
            <param name="type">Standard library type</param>
            <returns>List of native delegate functions found</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetBaseType(ExMat.ExObjType)">
            <summary>
            Get the base type of given object type
            </summary>
            <param name="type">Object type</param>
            <returns>Raw base type of given object type, stripped from flags</returns>
        </member>
        <member name="M:ExMat.API.ExApi.RandomString(System.Int32)">
            <summary>
            Create a cryptographically safe random string using characters from [a-zA-Z0-9]
            </summary>
            <param name="length">Length of the string</param>
            <returns>A random string of given <paramref name="length"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.ListObjFromStringArray(System.String[])">
            <summary>
            Create a list of objects from given array of strings
            </summary>
            <param name="arr">String array</param>
            <returns>A list of <see cref="F:ExMat.ExObjType.STRING"/> objects with string values from <paramref name="arr"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetSafeObject(ExMat.VM.ExVM,System.Int32,ExMat.ExObjType,ExMat.Objects.ExObject@)">
            <summary>
            Get an object from stack and assert a certain <paramref name="type"/>
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="idx">Object index: <see cref="F:ExMat.VM.ExVM.StackBase"/><c> + <paramref name="idx"/> - 1</c></param>
            <param name="type">Expected object type</param>
            <param name="res">Reference to a <see cref="F:ExMat.ExObjType.NULL"/> object to store the object from stack</param>
            <returns><see langword="true"/> if object was passed to <paramref name="res"/> 
            <para><see langword="false"/> if object type didn't match <paramref name="type"/></para></returns>
        </member>
        <member name="M:ExMat.API.ExApi.ConvertAndGetString(ExMat.VM.ExVM,System.Int32,System.Int32,System.String@)">
            <summary>
            Attempt to convert an argument passed to a native function to string and return it as given string
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="idx">Argument index</param>
            <param name="maxdepth">Stringification maximum depth</param>
            <param name="output">Output string</param>
            <returns><see langword="true"/> if stringfied successfully and assigned to <paramref name="output"/>, otherwise <see langword="false"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.CanBeep">
            <summary>
            Check if console beeping method is available
            </summary>
            <returns>Wheter <see cref="M:System.Console.Beep"/> can work</returns>
        </member>
        <member name="M:ExMat.API.ExApi.BeepAsync(System.Int32,System.Int32)">
            <summary>
            Invoke console beep method with given frequency and duration async
            </summary>
            <param name="freq">Frequency to beep at</param>
            <param name="dur">Duration to beep for</param>
            <returns>Returns true when the beeping starts</returns>
        </member>
        <member name="M:ExMat.API.ExApi.BeepAsync">
            <summary>
            Invoke console beep method async
            </summary>
            <returns>Returns true when the beeping starts</returns>
        </member>
        <member name="M:ExMat.API.ExApi.Beep(System.Int32,System.Int32)">
            <summary>
            Invoke console beep method with given frequency and duration
            </summary>
            <param name="freq">Frequency to beep at</param>
            <param name="dur">Duration to beep for</param>
            <returns>Returns true when the beeping ends</returns>
        </member>
        <member name="M:ExMat.API.ExApi.Beep">
            <summary>
            Invoke console beep method
            </summary>
            <returns>Returns true when the beeping ends</returns>
        </member>
        <member name="M:ExMat.API.ExApi.ToString(ExMat.VM.ExVM,System.Int32,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Stringify an object in stack
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="idx">Object index to stringify: <see cref="F:ExMat.VM.ExVM.StackBase"/><c> + <paramref name="idx"/> - 1</c></param>
            <param name="maxdepth">Printing depth. 
            <para><c>1</c> means <c>Array[i]</c> elements getting printed</para> <code>[1,"abc",[4,4]] -> [ 1, "abc", ARRAY(2)]</code>
            <c>2</c> for <c>Array[i][j]</c> getting printed <code>[1,"abc",[4,4]] -> [ 1, "abc", [4, 4]]</code></param>
            <param name="pop">Amount of objects to pop from stack, used for returning values in interactive console</param>
            <param name="beauty">Wheter to indent values in arrays and dictionaries, it may look too spaced out for larger objects</param>
            <returns><see langword="true"/> if object was successfully stringified
            <para><see langword="false"/> if there was an error stringifying the object</para></returns>
        </member>
        <member name="M:ExMat.API.ExApi.ToInteger(ExMat.VM.ExVM,ExMat.Objects.ExObject,ExMat.Objects.ExObject@)">
            <summary>
            Convert given object to an integer
            </summary>
            <param name="vm">Virtual machine to report errors to</param>
            <param name="obj">Object to convert</param>
            <param name="res">Resulting integer</param>
            <returns>Wheter conversion was successful</returns>
        </member>
        <member name="M:ExMat.API.ExApi.ToFloatFromStack(ExMat.VM.ExVM,System.Int32,System.Int32)">
            <summary>
            Parse an object as 64bit floating point value
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="idx">Object index to stringify: <see cref="F:ExMat.VM.ExVM.StackBase"/><c> + <paramref name="idx"/> - 1</c></param>
            <param name="pop">Amount of objects to pop from stack, used for returning values in interactive console</param>
            <returns><see langword="true"/> if object was successfully parsed as float
            <para><see langword="false"/> if there was an error parsing the object</para></returns>
        </member>
        <member name="M:ExMat.API.ExApi.ToIntegerFromStack(ExMat.VM.ExVM,System.Int32,System.Int32)">
            <summary>
            Parse an object as 64bit integer
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="idx">Object index to stringify: <see cref="F:ExMat.VM.ExVM.StackBase"/><c> + <paramref name="idx"/> - 1</c></param>
            <param name="pop">Amount of objects to pop from stack, used for returning values in interactive console</param>
            <returns><see langword="true"/> if object was successfully parsed as integer
            <para><see langword="false"/> if there was an error parsing the object</para></returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetFloatString(ExMat.Objects.ExObject)">
            <summary>
            Returns string format of a float
            </summary>
            <param name="obj">Value to get the string of</param>
            <returns>A formatted string</returns>
        </member>
        <member name="M:ExMat.API.ExApi.CheckEqual(ExMat.Objects.ExObject,ExMat.Objects.ExObject,System.Boolean@)">
            <summary>
            Checks equality of given two objects, store result in given argument <paramref name="res"/>
            </summary>
            <param name="x">First object</param>
            <param name="y">Second object</param>
            <param name="res">Result of equality check</param>
            <returns>Always returns <see langword="true"/>, stores result in <paramref name="res"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.CheckEqualReturnRes(ExMat.Objects.ExObject,ExMat.Objects.ExObject)">
            <summary>
            Checks equality of given two objects, returns the result
            </summary>
            <param name="x">First object</param>
            <param name="y">Second object</param>
            <returns><see langword="true"/> if <paramref name="x"/> and <paramref name="y"/> hold the same value, otherwise <see langword="false"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.FindInArray(System.Collections.Generic.List{ExMat.Objects.ExObject},ExMat.Objects.ExObject)">
            <summary>
            Checks if given object exists in given list
            </summary>
            <param name="lis">List to iterate over</param>
            <param name="key">Object to match</param>
            <returns><see langword="true"/> if <paramref name="key"/> has an equal object in <paramref name="lis"/>, otherwise <see langword="false"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetColorFromName(System.String,System.ConsoleColor)">
            <summary>
            Get console color from color name
            </summary>
            <param name="name">Color name</param>
            <param name="def">Backup value in case given <paramref name="name"/> didnt match anything.</param>
            <returns>Color represented by <paramref name="name"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.DecideEncodingFromString(System.String)">
            <summary>
            Get encoding from a string representation
            </summary>
            <param name="enc">String represtation of an encoding, use <see cref="F:System.String.Empty"/> for default encoding or one of (utf8, utf32, latin, unicode, ascii)</param>
            <returns>Encoding represented by <paramref name="enc"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetBits(System.Int64,System.Int32)">
            <summary>
            Get bits representation of an integer
            </summary>
            <param name="i">Integer to use</param>
            <param name="bits">Bits to pad to left</param>
            <returns>An array of zero and ones</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetNObjects(ExMat.VM.ExVM,System.Int32,System.Int32)">
            <summary>
            Get <paramref name="n"/> objects in an array from stack
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="n">Object index to stringify: <see cref="F:ExMat.VM.ExVM.StackBase"/><c> + <paramref name="start"/> + {0 to <paramref name="n"/>} - 1</c></param>
            <param name="start">Starting index above <see cref="F:ExMat.VM.ExVM.StackBase"/> base index<para>
            Most of the time first 2 above base are references for <see langword="this"/> and roottable</para></param>
            <returns>Array of objects in desired stack locations</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetString(ExMat.VM.ExVM,System.Int32,System.String@)">
            <summary>
            Get the string value stored in a <see cref="F:ExMat.ExObjType.STRING"/> object to a referenced string <paramref name="s"/>
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="idx">Object index to stringify: <see cref="F:ExMat.VM.ExVM.StackBase"/><c> + <paramref name="idx"/> - 1</c></param>
            <param name="s">String object to store the result in</param>
            <returns><see langword="true"/> if object was a <see cref="F:ExMat.ExObjType.STRING"/> object
            <para><see langword="false"/> if there was not a <see cref="F:ExMat.ExObjType.STRING"/> object</para></returns>
        </member>
        <member name="M:ExMat.API.ExApi.FindNativeFunction(ExMat.VM.ExVM,System.Collections.Generic.List{ExMat.Objects.ExNativeFunc},System.String)">
            <summary>
            Find a native function by name in a list of functions
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="fs">Function list</param>
            <param name="name">Name to search for</param>
            <returns>A <see cref="T:ExMat.Objects.ExNativeFunc"/> if <paramref name="name"/> was found in <paramref name="fs"/> list
            <para><see langword="null"/> if there was no functions named <paramref name="name"/> in <paramref name="fs"/></para></returns>
        </member>
        <member name="M:ExMat.API.ExApi.ReloadNativeFunction(ExMat.VM.ExVM,System.Type,System.String,System.Boolean)">
            <summary>
            Reload a native function in roottable
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="lib">Library to search in</param>
            <param name="name">Name of the function to reload</param>
            <param name="pop">Wheter to pop the root from stack after searching</param>
            <returns><see langword="true"/> if <paramref name="name"/> was found in <paramref name="lib"/> and reloaded
            <para><see langword="false"/> if there was no function named <paramref name="name"/> in <paramref name="lib"/></para></returns>
        </member>
        <member name="M:ExMat.API.ExApi.RegisterNativeFunction(ExMat.VM.ExVM,ExMat.Objects.ExNativeFunc,ExMat.ExStdLibType)">
            <summary>
            Register a native function to a virtual machines roottable
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="func">Native function</param>
            <param name="libtype">Library the <paramref name="func"/> is based on</param>
        </member>
        <member name="M:ExMat.API.ExApi.InvokeRegisterOnStdLib(ExMat.VM.ExVM,System.Type)">
            <summary>
            Invoke <see cref="T:ExMat.ExMat.StdLibRegistery"/> of given type on given virtual machine
            </summary>
            <param name="vm">Virtual machine to invoke the method with</param>
            <param name="type">Standard library type</param>
            <returns><see cref="F:ExMat.ExFunctionStatus.SUCCESS"/> on success, <see cref="F:ExMat.ExFunctionStatus.ERROR"/> otherwise</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetAllAssemblies">
            <summary>
            Get all assemblies defined in <see cref="P:ExMat.ExMat.Assemblies"/> into an array
            </summary>
            <returns>An array of assembly information</returns>
        </member>
        <member name="M:ExMat.API.ExApi.SetOptionsFromArguments(System.String[]@,System.Int32@)">
            <summary>
            Process given list of console parameters and flags
            </summary>
            <param name="args">List of console arguments</param>
            <param name="flags">Flag to update</param>
        </member>
        <member name="M:ExMat.API.ExApi.GetConsoleFlagHelperValues">
            <summary>
            Get console flag information
            </summary>
            <returns></returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetConsoleParameterHelperValues">
            <summary>
            Get console parameter information
            </summary>
            <returns></returns>
        </member>
        <member name="M:ExMat.API.ExApi.RegisterStdLibrary(ExMat.VM.ExVM,System.Type)">
            <summary>
            Register a standard library
            </summary>
            <param name="vm">Virtual machine to register the library to</param>
            <param name="lib">Standard library to register</param>
            <returns>Wheter registery was successful</returns>
        </member>
        <member name="M:ExMat.API.ExApi.RegisterStdLibraries(ExMat.VM.ExVM)">
            <summary>
            Register std libs from given assembly
            </summary>
            <param name="vm">Virtual machine to register libraries to</param>
            <returns>Wheter registery process was completed successfully</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetTypesFromAssemblies">
            <summary>
            Get all types defined in the executing assembly
            </summary>
            <returns>List of types defined in assembly</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetStandardLibraryTypes">
            <summary>
            Get all classes which are valid standard libraries
            </summary>
            <returns>List of standard library classes</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetStandardLibraryTypes(System.Reflection.Assembly[])">
            <summary>
            Get standard libraries defined in current assembly
            </summary>
            <param name="asm"></param>
            <returns>List of std lib types</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetLibraryTypeFromStdClass(System.Type)">
            <summary>
            Get the <see cref="T:ExMat.Attributes.ExStdLibBase"/> representation of a standard library
            </summary>
            <param name="stdClass">Standard library type object</param>
            <returns>Given stdlib type's <see cref="T:ExMat.Attributes.ExStdLibBase"/> representation</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetLibraryNameFromStdClass(System.Type)">
            <summary>
            Get the <see cref="T:ExMat.Attributes.ExStdLibName"/> name of a standard library
            </summary>
            <param name="stdClass">Standard library type object</param>
            <returns>Given stdlib type's <see cref="T:ExMat.Attributes.ExStdLibName"/> name or <see cref="F:System.String.Empty"/> if attribute doesn't exist</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetStdLibraryRegisteryMethod(System.Type)">
            <summary>
            Get the <see cref="T:ExMat.Attributes.ExStdLibRegister"/> named registery method of a standard library which is stored in a <see cref="T:ExMat.ExMat.StdLibRegistery"/> delegate property
            </summary>
            <param name="stdClass">Standard library type object</param>
            <returns>Given stdlib type's <see cref="T:ExMat.ExMat.StdLibRegistery"/> property with <see cref="T:ExMat.Attributes.ExStdLibRegister"/> name or <see langword="null"/> if it doesn't exist</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetStdLibraryConstsDict(System.Type)">
            <summary>
            Get the <see cref="T:ExMat.Attributes.ExStdLibConstDict"/> named constants dictionary of a standard library which is stored in a <see cref="T:System.Collections.Generic.Dictionary`2"/> property (&lt;<see cref="T:System.String"/>,<see cref="T:ExMat.Objects.ExObject"/>&gt;)
            </summary>
            <param name="stdClass">Standard library type object</param>
            <returns>Given stdlib type's <see cref="T:System.Collections.Generic.Dictionary`2"/> property (&lt;<see cref="T:System.String"/>,<see cref="T:ExMat.Objects.ExObject"/>&gt;) with <see cref="T:ExMat.Attributes.ExStdLibConstDict"/> name or <see langword="null"/> if it doesn't exist</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetStdLibraryRegisteryName(System.Type)">
            <summary>
            Get the <see cref="F:ExMat.Attributes.ExStdLibRegister.RegisterMethodName"/> of a standard library 
            </summary>
            <param name="stdClass">Standard library type object</param>
            <returns>Given stdlib type's <see cref="T:ExMat.Attributes.ExStdLibRegister"/> register name or <see cref="F:System.String.Empty"/> if attribute doesn't exist</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetStdLibraryConstsName(System.Type)">
            <summary>
            Get the <see cref="F:ExMat.Attributes.ExStdLibConstDict.Name"/> of a standard library 
            </summary>
            <param name="stdClass">Standard library type object</param>
            <returns>Given stdlib type's <see cref="T:ExMat.Attributes.ExStdLibConstDict"/> constants dictionary name or <see cref="F:System.String.Empty"/> if attribute doesn't exist</returns>
        </member>
        <member name="M:ExMat.API.ExApi.IsStdLib(System.Type)">
            <summary>
            Check if given class has <see cref="T:ExMat.Attributes.ExStdLibName"/> attribute defined
            </summary>
            <param name="stdClass">Class to check</param>
            <returns><see langword="true"/> if <paramref name="stdClass"/> is a std lib, otherwise <see langword="false"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.RegisterNativeFunctions(ExMat.VM.ExVM,System.Type)">
            <summary>
            Register native functions to a virtual machines roottable
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="lib">Standard library type object to get the native functions from</param>
        </member>
        <member name="M:ExMat.API.ExApi.CreateConstantInt(ExMat.VM.ExVM,System.String,System.Int64)">
            <summary>
            Create a constant 64bit integer value
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="name">Name of the constant</param>
            <param name="val">Constant's value</param>
        </member>
        <member name="M:ExMat.API.ExApi.CreateConstantFloat(ExMat.VM.ExVM,System.String,System.Double)">
            <summary>
            Create a constant 64bit float value
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="name">Name of the constant</param>
            <param name="val">Constant's value</param>
        </member>
        <member name="M:ExMat.API.ExApi.CreateConstantString(ExMat.VM.ExVM,System.String,System.String)">
            <summary>
            Create a constant string
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="name">Name of the constant</param>
            <param name="val">Constant's value</param>
        </member>
        <member name="M:ExMat.API.ExApi.CreateConstantSpace(ExMat.VM.ExVM,System.String,ExMat.Objects.ExSpace)">
            <summary>
            Create a constant space
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="name">Name of the constant</param>
            <param name="val">Constant's value</param>
        </member>
        <member name="M:ExMat.API.ExApi.CreateConstantDict(ExMat.VM.ExVM,System.String,System.Collections.Generic.Dictionary{System.String,ExMat.Objects.ExObject})">
            <summary>
            Create a constant dictionary
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="name">Name of the constant</param>
            <param name="dict">Dictionary</param>
        </member>
        <member name="M:ExMat.API.ExApi.CreateConstantList(ExMat.VM.ExVM,System.String,System.Collections.Generic.List{ExMat.Objects.ExObject})">
            <summary>
            Create a constant list
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="name">Name of the constant</param>
            <param name="lis">List</param>
        </member>
        <member name="M:ExMat.API.ExApi.PushString(ExMat.VM.ExVM,System.String,System.Int32)">
            <summary>
            Push a string to a virtual machine's stack
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="str">String to push to stack</param>
            <param name="len">If above zero, pushes <paramref name="str"/><c>[<see cref="T:System.Range"/>(0, len)]</c></param>
        </member>
        <member name="M:ExMat.API.ExApi.CreateClosure(ExMat.VM.ExVM,ExMat.ExMat.StdLibFunction)">
            <summary>
            Create a native closure from a native function and push to a virtual machine's stack
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="f">Native function to create a closure of</param>
        </member>
        <member name="M:ExMat.API.ExApi.SetNativeClosureName(ExMat.VM.ExVM,System.Int32,System.String)">
            <summary>
            Set a name of a native function
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="id">Native function index at stack <see cref="F:ExMat.VM.ExVM.StackBase"/><c> + <paramref name="id"/> - 1</c></param>
            <param name="name">New name for the native function</param>
        </member>
        <member name="M:ExMat.API.ExApi.GetExpectedTypes(System.Int32)">
            <summary>
            Get the type names from a mask
            </summary>
            <param name="mask">Mask to get type names from</param>
            <returns>Type names found in <paramref name="mask"/> wrapped in <c>(</c> and <c>)</c> seperated with <c>,</c></returns>
        </member>
        <member name="M:ExMat.API.ExApi.CompileTypeChar(System.Char)">
            <summary>
            Get the integer <see cref="T:ExMat.ExBaseType"/> representation of a given character mask. Refer to <see cref="F:ExMat.ExMat.TypeMasks"/>
            <param name="c">Character mask</param>
            </summary>
            <returns>Integer parsed representation of given mask <paramref name="c"/>
            <para> If mask is unknown, returns <see cref="F:System.Int32.MaxValue"/></para></returns>
        </member>
        <member name="M:ExMat.API.ExApi.DecompileTypeMaskChar(ExMat.ExBaseType)">
            <summary>
            Get string representation of a object type mask
            </summary>
            <param name="mask">Mask to decompile to string form</param>
            <returns>String form of given mask</returns>
        </member>
        <member name="M:ExMat.API.ExApi.DecompileTypeMaskChar(System.Int32)">
            <summary>
            Get string representation of a object type mask, same as <see cref="M:ExMat.API.ExApi.DecompileTypeMaskChar(ExMat.ExBaseType)"/>
            </summary>
            <param name="c">Integer mask to decompile to string form</param>
            <returns>String form of given mask</returns>
        </member>
        <member name="M:ExMat.API.ExApi.CompileTypeMask(System.String,System.Collections.Generic.List{System.Int32})">
            <summary>
            Compile a string mask into list of parameter masks for expected types
            </summary>
            <param name="mask">String mask for expected types for parameters, refer to <see cref="F:ExMat.ExMat.TypeMasks"/> method</param>
            <param name="results">Compilation results from <paramref name="mask"/> for each parameter</param>
            <returns><see langword="true"/> if mask was compiled successfully, otherwise <see langword="false"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetSimpleString(ExMat.Objects.ExObject)">
            <summary>
            Get a simple stringification of given object
            </summary>
            <param name="obj">Object to stringify</param>
            <returns>Resulting stringification of <paramref name="obj"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetRepeatCounts(System.Collections.Generic.List{ExMat.Objects.ExObject})">
            <summary>
            Get a dictionary of object repeat counts in a list
            </summary>
            <param name="lis">List of objects to iterate</param>
            <returns>A dictionary with elements of <paramref name="lis"/> as keys, and how many times they appear in <paramref name="lis"/> as values</returns>
        </member>
        <member name="M:ExMat.API.ExApi.SetParamCheck(ExMat.VM.ExVM,System.Int32,System.String)">
            <summary>
            Set parameter checks for the native function on top of the stack of <paramref name="vm"/>
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="n">Used to decide required amount of arguments, shouldn't be equal to <c>0</c>
            <para> <paramref name="n"/> less than <c>0</c> : Has -<paramref name="n"/> parameters, -<paramref name="n"/> + <c>1</c> required</para>
            <para><paramref name="n"/> higher than <c>0</c> : Has <paramref name="n"/> - <c>1</c> parameters, <paramref name="n"/> - <c>1</c> required</para></param>
            <param name="mask">Parameter type masks to compile</param>
        </member>
        <member name="M:ExMat.API.ExApi.GetDefaultValuesFromParameters(System.Collections.Generic.List{ExMat.Objects.ExNativeParam})">
            <summary>
            Create a dictionary of parameter indices and default values from a given parameter list
            </summary>
            <param name="ps">List of parameters</param>
            <returns>Parameter index and default value filled dictionary</returns>
        </member>
        <member name="M:ExMat.API.ExApi.SetDefaultValues(ExMat.VM.ExVM,System.Collections.Generic.List{ExMat.Objects.ExNativeParam})">
            <summary>
            Set default values for parameters
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="ps">List of native parameters</param>
        </member>
        <member name="M:ExMat.API.ExApi.CreateNewSlot(ExMat.VM.ExVM,System.Int32,System.Boolean,System.String)">
            <summary>
            Creates a new key-value pair in a dictionary or a member in a class
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="idx">Stack index of target object to create a new slot on:
            <para><see cref="F:ExMat.VM.ExVM.StackBase"/><c> + <paramref name="idx"/> - 1</c></para></param>
            <param name="isConst">Wheter this is a const slot</param>
            <param name="name">Name of the constant if <paramref name="isConst"/> is true</param>
        </member>
        <member name="M:ExMat.API.ExApi.CountValueEqualsInArray(System.Collections.Generic.List{ExMat.Objects.ExObject},ExMat.Objects.ExObject)">
            <summary>
            Count how many times an object appears in a list
            </summary>
            <param name="lis">List of objects to iterate through</param>
            <param name="obj">Object to count appearences of</param>
            <returns>Count of <paramref name="obj"/> in <paramref name="lis"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetValueIndexFromArray(System.Collections.Generic.List{ExMat.Objects.ExObject},ExMat.Objects.ExObject)">
            <summary>
            Find the index of an object in a list
            </summary>
            <param name="lis">List of objects to iterate through</param>
            <param name="obj">Objects to search for the index</param>
            <returns>First index <paramref name="obj"/> appears in <paramref name="lis"/> or <c>-1</c> if object wasn't found in the list</returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetFunctionAttribute(ExMat.Interfaces.IExClosure,System.String,ExMat.Objects.ExObject@)">
            <summary>
            Gets an attribute of a given function and assigns it to given destination
            </summary>
            <param name="func">Function to get the attribute from</param>
            <param name="attr">Attribute name</param>
            <param name="dest">Attribute's value if found</param>
            <returns>If attribute exists <see cref="F:ExMat.ExGetterStatus.FOUND"/>, otherwise <see cref="F:ExMat.ExGetterStatus.ERROR"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.ParseStringToInteger(System.String,ExMat.Objects.ExObject@)">
            <summary>
            Parse string to integer, allows hex and binary
            </summary>
            <param name="s">String to parse</param>
            <param name="res">Resulting value</param>
            <returns><see langword="true"/> if parsing was successful, otherwise <see langword="false"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.ParseStringToFloat(System.String,ExMat.Objects.ExObject@)">
            <summary>
            Parse string to float, allows hex and binary
            </summary>
            <param name="s">String to parse</param>
            <param name="res">Resulting value</param>
            <returns><see langword="true"/> if parsing was successful, otherwise <see langword="false"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.CompileSource(ExMat.VM.ExVM,System.String)">
            <summary>
            Compile a code string and push resulting <see langword="main"/> function to virtual machine stack
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="source">Code string to compile</param>
            <returns><see langword="true"/> if <paramref name="source"/> was compiled successfully
            <para><see langword="false"/> if there was a compilation error</para></returns>
        </member>
        <member name="M:ExMat.API.ExApi.PushRootTable(ExMat.VM.ExVM)">
            <summary>
            Push the roottable to virtual machine's stack
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <returns>Always returns <see langword="true"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.PushConstsTable(ExMat.VM.ExVM)">
            <summary>
            Push the constants table to given VM's stack
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <returns>Always returns <see langword="true"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetFromStack(ExMat.VM.ExVM,System.Int32)">
            <summary>
            Get an object from a virtual machine's stack
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <param name="idx">Stack index of the object:
            <para>if <paramref name="idx"/> less than 0: <see cref="F:ExMat.VM.ExVM.StackTop"/><c> - <paramref name="idx"/></c></para>
            <para>if <paramref name="idx"/> higher than 0: <see cref="F:ExMat.VM.ExVM.StackBase"/><c> + <paramref name="idx"/> - 1</c></para></param>
            <returns>Object from the <see cref="F:ExMat.VM.ExVM.Stack"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.GetTopOfStack(ExMat.VM.ExVM)">
            <summary>
            Calculate how far top is from base
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <returns><see cref="F:ExMat.VM.ExVM.StackTop"/> - <see cref="F:ExMat.VM.ExVM.StackBase"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.Call(ExMat.VM.ExVM,System.Int32,System.Boolean,System.Boolean)">
            <summary>
            Call a closure with given amount of arguments from stack. Is also used to execute <c>main</c> from stack.
            </summary>
            <param name="vm">Virtual machine to use</param>
            <param name="nArguments">Amount of arguments to pick from top of the stack</param>
            <param name="returnVal">Wheter to push resulting value to stack</param>
            <param name="forceReturn">Wheter to return last statement's return value in case there is no return statement.
            <para>This helps interactive console display values without return statements</para></param>
            <returns><see langword="true"/> if call was executed successfully
            <para><see langword="false"/> if there was a runtime error</para></returns>
        </member>
        <member name="M:ExMat.API.ExApi.TransposeMatrix(System.Int32,System.Int32,System.Collections.Generic.List{ExMat.Objects.ExObject})">
            <summary>
            Transpose a matrix of <see cref="T:ExMat.Objects.ExObject"/>s
            </summary>
            <param name="rows">Amount of rows</param>
            <param name="cols">Amount of columns</param>
            <param name="vals">List of <see cref="F:ExMat.ExObjType.ARRAY"/> objects</param>
            <returns>Transposed list of <see cref="F:ExMat.ExObjType.ARRAY"/> objects with <c><paramref name="cols"/> x <paramref name="rows"/></c> dimensions</returns>
        </member>
        <member name="M:ExMat.API.ExApi.DoMatrixTransposeChecks(ExMat.VM.ExVM,System.Collections.Generic.List{ExMat.Objects.ExObject},System.Int32@)">
            <summary>
            Assert transpose operation rules on given matrix and get column count
            </summary>
            <param name="vm">Virtual machine to use in case of errors</param>
            <param name="vals">List of <see cref="F:ExMat.ExObjType.ARRAY"/> objects</param>
            <param name="cols">Integer variable to store column count if there were no errors</param>
            <returns><see langword="true"/> if <paramref name="vals"/> was a valid matrix
            <para><see langword="false"/> if <paramref name="vals"/> wasn't a valid matrix</para></returns>
        </member>
        <member name="M:ExMat.API.ExApi.ConvertIntegerStringArrayToString(System.Collections.Generic.List{ExMat.Objects.ExObject},System.Text.StringBuilder@)">
            <summary>
            Convert a list of strings or integers to a single string
            </summary>
            <param name="lis">List of strings or integers in range [0,<see cref="F:System.Char.MaxValue"/>]</param>
            <param name="str">Output string</param>
            <returns>Wheter given list was valid and operations were completed successfully</returns>
        </member>
        <member name="M:ExMat.API.ExApi.Escape(System.String)">
            <summary>
            Escape the non-printable characters in given string
            </summary>
            <param name="str">String to use</param>
            <returns>A new string with non-printable characters escaped</returns>
        </member>
        <member name="M:ExMat.API.ExApi.ApplyPreferredConsoleTitle(System.String)">
            <summary>
            Change console title
            </summary>
            <param name="title">New title</param>
        </member>
        <member name="M:ExMat.API.ExApi.WriteInfoString(ExMat.VM.ExVM)">
            <summary>
            Writes version and program info in different colors
            </summary>
            <param name="vm">Virtual machine to get information from</param>
        </member>
        <member name="M:ExMat.API.ExApi.WriteOut(ExMat.VM.ExVM)">
            <summary>
            Writes <see cref="F:ExMat.VM.ExVM.InputCount"/>th output line's beginning
            </summary>
            <param name="vm">Virtual machine to write to</param>
        </member>
        <member name="M:ExMat.API.ExApi.WriteIn(ExMat.VM.ExVM)">
            <summary>
            Writes <see cref="F:ExMat.VM.ExVM.InputCount"/>th input line's beginning
            </summary>
            <param name="vm">Virtual machine to write to</param>
        </member>
        <member name="M:ExMat.API.ExApi.SleepVM(ExMat.VM.ExVM,System.Int32)">
            <summary>
            Sleep the main thread for given amount of miliseconds
            </summary>
            <param name="vm">Virtual machine to track sleeping</param>
            <param name="time">Miliseconds to sleep</param>
        </member>
        <member name="M:ExMat.API.ExApi.GetFormatStringAndObjects(ExMat.VM.ExVM,System.Int32,System.String@,System.Object[]@)">
            <summary>
            Get formatted string and objects to pass to it from given virtual machine's stack
            </summary>
            <param name="vm">Virtual machine to use</param>
            <param name="nargs">Amount of arguments for formatted string</param>
            <param name="format">Output formatted string</param>
            <param name="ps">Array of objects to pass to formatted string</param>
            <returns><see cref="F:ExMat.ExFunctionStatus.SUCCESS"/> if all objects successfully get stringified, otherwise <see cref="F:ExMat.ExFunctionStatus.ERROR"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.CallTop(ExMat.VM.ExVM)">
            <summary>
            Call the closure on top of the virtual stack
            </summary>
            <param name="vm">Virtual machine to use the stack of</param>
            <returns><code>-1</code> if there was an error
            <para><code>0</code> if call was successful</para>
            <para><see cref="F:ExMat.VM.ExVM.ExitCode"/> of <paramref name="vm"/> if exit was requested</para></returns>
        </member>
        <member name="M:ExMat.API.ExApi.CollectGarbage">
            <summary>
            Call garbage collector
            </summary>
        </member>
        <member name="M:ExMat.API.ExApi.Start(System.Boolean)">
            <summary>
            Initialize a virtual machine with given stack size
            </summary>
            <param name="interacive">Wheter to make the virtual machine interactive</param>
            <returns>A new virtual machine instance with stack size <see cref="P:ExMat.ExMat.PreferredStackSize"/></returns>
        </member>
        <member name="M:ExMat.API.ExApi.ClearErrorMessages(ExMat.VM.ExVM)">
            <summary>
            Clear error messages in the vm
            </summary>
            <param name="vm">VM to clear messages from</param>
        </member>
        <member name="M:ExMat.API.ExApi.WriteErrorTraces(ExMat.VM.ExVM)">
            <summary>
            Writes error traces stored in a virtual machine to console
            </summary>
            <param name="vm">Virtual machine to use</param>
        </member>
        <member name="M:ExMat.API.ExApi.WriteErrorMessages(ExMat.VM.ExVM,ExMat.ExErrorType)">
            <summary>
            Write error messages depending on the error type
            </summary>
            <param name="vm">Virtual machine to use</param>
            <param name="typ">Type of error</param>
            <returns>Always returns <c>-1</c></returns>
        </member>
        <member name="M:ExMat.InfoVar.ExCallInfo.Dispose">
            <summary>
            Disposer
            </summary>
        </member>
        <member name="T:ExMat.Exceptions.ExCompilerException">
            <summary>
            <see cref="T:ExMat.Compiler.ExCompiler"/> exception class
            </summary>
        </member>
        <member name="T:ExMat.Exceptions.ExExceptionType">
            <summary>
            Exception types
            </summary>
        </member>
        <member name="F:ExMat.Exceptions.ExExceptionType.BASE">
            <summary>
            Internal
            </summary>
        </member>
        <member name="F:ExMat.Exceptions.ExExceptionType.COMPILER">
            <summary>
            Compiler
            </summary>
        </member>
        <member name="F:ExMat.Exceptions.ExExceptionType.RUNTIME">
            <summary>
            VM, runtime
            </summary>
        </member>
        <member name="T:ExMat.Exceptions.ExException">
            <summary>
            Base class for exceptions
            </summary>
        </member>
        <member name="P:ExMat.Exceptions.ExException.Type">
            <summary>
            Exception type
            </summary>
        </member>
        <member name="M:ExMat.Exceptions.ExException.#ctor">
            <summary>
            Exception constructor
            </summary>
        </member>
        <member name="M:ExMat.Exceptions.ExException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
        </member>
        <member name="M:ExMat.Exceptions.ExException.#ctor(ExMat.VM.ExVM,System.String)">
            <summary>
            Exception constructor
            </summary>
        </member>
        <member name="M:ExMat.Exceptions.ExException.#ctor(ExMat.VM.ExVM,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
        </member>
        <member name="M:ExMat.Exceptions.ExException.#ctor(ExMat.VM.ExVM,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Exception constructor
            </summary>
        </member>
        <member name="M:ExMat.Exceptions.ExException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Exception constructor
            </summary>
        </member>
        <member name="M:ExMat.Exceptions.ExException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
        </member>
        <member name="T:ExMat.Exceptions.ExRuntimeException">
            <summary>
            <see cref="T:ExMat.VM.ExVM"/> exception class
            </summary>
        </member>
        <member name="P:ExMat.Exceptions.ExRuntimeException.Type">
            <summary>
            Exception type
            </summary>
        </member>
        <member name="M:ExMat.Exceptions.ExRuntimeException.#ctor">
            <summary>
            Exception constructor
            </summary>
        </member>
        <member name="M:ExMat.Exceptions.ExRuntimeException.#ctor(System.String)">
            <summary>
            Exception constructor
            </summary>
        </member>
        <member name="M:ExMat.Exceptions.ExRuntimeException.#ctor(ExMat.VM.ExVM,System.String)">
            <summary>
            Exception constructor
            </summary>
        </member>
        <member name="M:ExMat.Exceptions.ExRuntimeException.#ctor(System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
        </member>
        <member name="M:ExMat.Exceptions.ExRuntimeException.#ctor(ExMat.VM.ExVM,System.String,System.Exception)">
            <summary>
            Exception constructor
            </summary>
        </member>
        <member name="M:ExMat.Exceptions.ExRuntimeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Exception constructor
            </summary>
        </member>
        <member name="M:ExMat.Exceptions.ExRuntimeException.#ctor(ExMat.VM.ExVM,System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Exception constructor
            </summary>
        </member>
        <member name="T:ExMat.ExClass.ExClass">
            <summary>
            Class object
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExClass.Base">
            <summary>
            WIP, base class
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExClass.Members">
            <summary>
            Member names and values
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExClass.MetaFuncs">
            <summary>
            Meta methods list
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExClass.DefaultValues">
            <summary>
            Default values for members used for instancing
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExClass.Methods">
            <summary>
            Methods defined
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExClass.Attributes">
            <summary>
            Attributes dictionary
            </summary>
        </member>
        <member name="P:ExMat.ExClass.ExClass.HasInstances">
            <summary>
            Has this class ever been instanced ?
            </summary>
        </member>
        <member name="P:ExMat.ExClass.ExClass.ConstructorIndex">
            <summary>
            Method list index of the constructor
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExClass.SharedState">
            <summary>
            Shared state of the VM
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExClass.Hash">
            <summary>
            Unique hash value for the class for comparison
            </summary>
        </member>
        <member name="M:ExMat.ExClass.ExClass.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:ExMat.ExClass.ExClass.#ctor(ExMat.States.ExSState,ExMat.ExClass.ExClass)">
            <summary>
            Class within given shared state and base class
            </summary>
            <param name="exS">Shared state</param>
            <param name="b">Base class or <see langword="null"/></param>
        </member>
        <member name="M:ExMat.ExClass.ExClass.Create(ExMat.States.ExSState,ExMat.ExClass.ExClass)">
            <summary>
            Static method to call the constructor
            </summary>
            <param name="exs">Shared state</param>
            <param name="b">Base class</param>
            <returns>A new class</returns>
        </member>
        <member name="M:ExMat.ExClass.ExClass.CreateInstance">
            <summary>
            Create an instance of this class
            </summary>
            <returns>A new instance</returns>
        </member>
        <member name="M:ExMat.ExClass.ExClass.GetConstructor(ExMat.Objects.ExObject@)">
            <summary>
            Get the constructor method of the class if any. <paramref name="o"/> will be <see langword="null"/> if there is no constructor
            </summary>
            <param name="o">Result method</param>
            <returns>Wheter there were a constructor method</returns>
        </member>
        <member name="M:ExMat.ExClass.ExClass.SetAttrs(ExMat.Objects.ExObject,ExMat.Objects.ExObject)">
            <summary>
            Set an attribute to given value
            </summary>
            <param name="key">Attribute name</param>
            <param name="val">New value</param>
            <returns>Wheter an attribute of given name <paramref name="key"/> existed and updated</returns>
        </member>
        <member name="T:ExMat.ExClass.ExClassMem">
            <summary>
            Class member class
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExClassMem.Value">
            <summary>
            Value stored
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExClassMem.Attributes">
            <summary>
            Custom attributes of this member
            </summary>
        </member>
        <member name="M:ExMat.ExClass.ExClassMem.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:ExMat.ExClass.ExClassMem.#ctor(ExMat.ExClass.ExClassMem)">
            <summary>
            Shallow copying other member
            </summary>
            <param name="mem">Other to copy from</param>
        </member>
        <member name="M:ExMat.ExClass.ExClassMem.Dispose">
            <summary>
            Disposer
            </summary>
        </member>
        <member name="T:ExMat.ExClass.ExInstance">
            <summary>
            Instance object model
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExInstance.Delegate">
            <summary>
            Meta methods and other delegates dictionary
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExInstance.SharedState">
            <summary>
            Shared state
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExInstance.Class">
            <summary>
            Class instanced from
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExInstance.MemberValues">
            <summary>
            Members list
            </summary>
        </member>
        <member name="F:ExMat.ExClass.ExInstance.Hash">
            <summary>
            Unique hash value
            </summary>
        </member>
        <member name="M:ExMat.ExClass.ExInstance.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:ExMat.ExClass.ExInstance.GetMetaM(ExMat.ExMetaMethod,ExMat.Objects.ExObject@)">
            <summary>
            Get a meta method from <see cref="F:ExMat.ExClass.ExInstance.Delegate"/> dictionary
            </summary>
            <param name="m">Neta method</param>
            <param name="res">Result closure object</param>
            <returns>Wheter meta method was defined and found</returns>
        </member>
        <member name="M:ExMat.ExClass.ExInstance.Init(ExMat.States.ExSState)">
            <summary>
            Initialize <see cref="F:ExMat.ExClass.ExInstance.Delegate"/> and increment <see cref="F:ExMat.ExClass.ExInstance.Class"/> reference count
            </summary>
            <param name="exs">Shared state</param>
        </member>
        <member name="M:ExMat.ExClass.ExInstance.Create(ExMat.States.ExSState,ExMat.ExClass.ExClass)">
            <summary>
            Create and initialize instance from given class
            </summary>
            <param name="exS">Shared state</param>
            <param name="cls">Class to instance from</param>
            <returns>Created instance</returns>
        </member>
        <member name="M:ExMat.ExClass.ExInstance.IsInstanceOf(ExMat.ExClass.ExClass)">
            <summary>
            Check if the instance is an instance of given class
            </summary>
            <param name="cls">Class to check</param>
            <returns>Wheter the instance was instanced from <paramref name="cls"/> class</returns>
        </member>
        <member name="T:ExMat.Closure.ExClosure">
            <summary>
            Closure model, can return values and can be called
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExClosure.Base">
            <summary>
            Base object this closure belongs to or null
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExClosure.Function">
            <summary>
            Function prototype
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExClosure.SharedState">
            <summary>
            Shared state
            </summary>
        </member>
        <member name="M:ExMat.Closure.ExClosure.Create(ExMat.States.ExSState,ExMat.FuncPrototype.ExPrototype)">
            <summary>
            Initialize a closure using given shared state and the prototype
            </summary>
            <param name="exS">Shared state</param>
            <param name="fpro">Prototype</param>
            <returns>A new closure</returns>
        </member>
        <member name="M:ExMat.Closure.ExClosure.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:ExMat.Closure.ExClosure.GetAttribute(System.String)">
            <summary>
            Get an attribute of the closure
            <para>Built in names:</para>
            <para><see cref="F:ExMat.ExMat.FuncName"/></para>
            <para><see cref="F:ExMat.ExMat.VargsName"/></para>
            <para><see cref="F:ExMat.ExMat.DelegName"/></para>
            <para><see cref="F:ExMat.ExMat.nParams"/></para>
            <para><see cref="F:ExMat.ExMat.nDefParams"/></para>
            <para><see cref="F:ExMat.ExMat.nMinArgs"/></para>
            <para><see cref="F:ExMat.ExMat.DefParams"/></para>
            <para>Or checks <see cref="F:ExMat.Closure.ExClosure.Base"/> class's attribute if nothing has matches</para>
            </summary>
            <param name="attr">Attribute name</param>
            <returns>Depends on the attribute requested</returns>
        </member>
        <member name="T:ExMat.Closure.ExNativeClosure">
            <summary>
            Native closure model
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExNativeClosure.SharedState">
            <summary>
            Shared state
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExNativeClosure.Name">
            <summary>
            Name of the closure
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExNativeClosure.Function">
            <summary>
            Function to use for calls
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExNativeClosure.IsDelegateFunction">
            <summary>
            Wheter this is a delegate function closure
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExNativeClosure.nOuters">
            <summary>
            Outer value count
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExNativeClosure.OutersList">
            <summary>
            Outers
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExNativeClosure.TypeMasks">
            <summary>
            Type masks for each parameter. If <see langword="null"/>, vargs is enabled
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExNativeClosure.nParameterChecks">
            <summary>
            Parameter check value. 
            <para>Works together with <see cref="F:ExMat.Closure.ExNativeClosure.TypeMasks"/></para>
            <para>Positive 'n': n - 1 parameters == n - 1 arguments</para>
            <para>Negative 'n': -n parameters == -n - 1 arguments minimum</para>
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExNativeClosure.DefaultValues">
            <summary>
            Default parameter values with their parameter numbers
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExNativeClosure.Documentation">
            <summary>
            Full documentation
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExNativeClosure.Summary">
            <summary>
            Short description
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExNativeClosure.Returns">
            <summary>
            Return type
            </summary>
        </member>
        <member name="F:ExMat.Closure.ExNativeClosure.Base">
            <summary>
            Base object type
            </summary>
        </member>
        <member name="M:ExMat.Closure.ExNativeClosure.GetAttribute(System.String)">
            <summary>
            Get an attribute of the closure
            <para>Built in names:</para>
            <para><see cref="F:ExMat.ExMat.FuncName"/></para>
            <para><see cref="F:ExMat.ExMat.HelpName"/></para>
            <para><see cref="F:ExMat.ExMat.DocsName"/></para>
            <para><see cref="F:ExMat.ExMat.VargsName"/></para>
            <para><see cref="F:ExMat.ExMat.DelegName"/></para>
            <para><see cref="F:ExMat.ExMat.nParams"/></para>
            <para><see cref="F:ExMat.ExMat.nDefParams"/></para>
            <para><see cref="F:ExMat.ExMat.nMinArgs"/></para>
            <para><see cref="F:ExMat.ExMat.DefParams"/></para>
            <para>Or returns null</para>
            </summary>
            <param name="attr">Attribute name</param>
            <returns>Depends on the attribute requested</returns>
        </member>
        <member name="M:ExMat.Closure.ExNativeClosure.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:ExMat.Closure.ExNativeClosure.Create(ExMat.States.ExSState,ExMat.ExMat.StdLibFunction,System.Int32)">
            <summary>
            Create a new native closure with given std lib function
            </summary>
            <param name="exS">Shared state</param>
            <param name="f">Std lib method</param>
            <param name="nout">Number of outer vals</param>
            <returns>Created native closure</returns>
        </member>
        <member name="T:ExMat.Objects.ExDisposer">
            <summary>
            Object disposer method provider
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExDisposer.DisposeList``1(System.Collections.Generic.List{``0}@)">
            <summary>
            Dispose given list and assign <see langword="null"/> to it
            </summary>
            <typeparam name="T">List element type</typeparam>
            <param name="lis">List of disposable objects</param>
        </member>
        <member name="M:ExMat.Objects.ExDisposer.DisposeDict``2(System.Collections.Generic.Dictionary{``0,``1}@)">
            <summary>
            Dispose given dictionary and assign <see langword="null"/> to it
            </summary>
            <typeparam name="TKey">Type doesn't matter</typeparam>
            <typeparam name="TValue">Disposable dictionary value type</typeparam>
            <param name="dict">Dictionary to dispose</param>
        </member>
        <member name="M:ExMat.Objects.ExDisposer.DisposeObjects``1(``0[])">
            <summary>
            Dispose given objects
            </summary>
            <typeparam name="T">Disposable type</typeparam>
            <param name="ps">Objects to dispose</param>
        </member>
        <member name="M:ExMat.Objects.ExDisposer.DisposeObject``1(``0@)">
            <summary>
            Dispose given object and assign <see langword="null"/> to it
            </summary>
            <typeparam name="T">Disposable type</typeparam>
            <param name="o">Object to dispose</param>
        </member>
        <member name="T:ExMat.Objects.ExList">
            <summary>
            Class to create <see cref="M:ExMat.Objects.ExObject.#ctor(System.Collections.Generic.List{ExMat.Objects.ExObject})"/>
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExList.#ctor">
            <summary>
            Empty list constructor
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExList.#ctor(System.Collections.Generic.List{ExMat.Objects.ExObject})">
            <summary>
            List constructor
            </summary>
            <param name="e">List of objects</param>
        </member>
        <member name="M:ExMat.Objects.ExList.#ctor(System.Char[])">
            <summary>
            Character array to object list
            </summary>
            <param name="e">Char array to store</param>
        </member>
        <member name="M:ExMat.Objects.ExList.#ctor(System.String[])">
            <summary>
            String array to object list
            </summary>
            <param name="e">String array to store</param>
        </member>
        <member name="M:ExMat.Objects.ExList.#ctor(System.Collections.Generic.List{System.String})">
            <summary>
            String list to object list
            </summary>
            <param name="e">String list to store</param>
        </member>
        <member name="T:ExMat.Objects.ExNativeFunc">
            <summary>
            Native function registery class
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExNativeFunc.Base">
            <summary>
            Library of which this function is a part of 
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExNativeFunc.Function">
            <summary>
            Function reference
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExNativeFunc.Parameters">
            <summary>
            Parameter information
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExNativeFunc.ParameterMask">
            <summary>
            Combined parameter type mask string
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExNativeFunc.ReturnsType">
            <summary>
            Information string about return type
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExNativeFunc.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExNativeFunc.#ctor(ExMat.ExMat.StdLibFunction)">
            <summary>
            Construct a native function from a standard library method
            </summary>
            <param name="foo">Standard library method</param>
        </member>
        <member name="M:ExMat.Objects.ExNativeFunc.#ctor(ExMat.ExMat.StdLibFunction,System.Char)">
            <summary>
            Construct a delegate native function from a standard library method
            </summary>
            <param name="foo">Standard library method</param>
            <param name="baseMask">Delegate base</param>
        </member>
        <member name="M:ExMat.Objects.ExNativeFunc.Dispose">
            <summary>
            Disposer
            </summary>
        </member>
        <member name="T:ExMat.Objects.ExNativeParam">
            <summary>
            Native function parameter class
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExNativeParam.Type">
            <summary>
            Parameter type mask using <see cref="T:ExMat.ExObjType"/> combinations
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExNativeParam.TypeMaskString">
            <summary>
            Parameter type mask info string using <see cref="T:ExMat.ExObjType"/> combinations
            </summary>
        </member>
        <member name="P:ExMat.Objects.ExNativeParam.HasDefaultValue">
            <summary>
            Wheter this parameter has a default value
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExNativeParam.Valid">
            <summary>
            Wheter this parameter is a valid parameter
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExNativeParam.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExNativeParam.#ctor(ExMat.Attributes.ExNativeParamBase)">
            <summary>
            
            </summary>
            <param name="ex"></param>
        </member>
        <member name="T:ExMat.Objects.ExObject">
            <summary>
            Base object model
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExObject.Type">
            <summary>
            Object type
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExObject.Value">
            <summary>
            Basic values: integer, float, boolean, complex(imaginary factor)
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExObject.ValueCustom">
            <summary>
            Custom values
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetInt">
            <summary>
            Get the integer value stored
            </summary>
            <returns>If <see cref="F:ExMat.Objects.ExObject.Type"/> is <see cref="F:ExMat.ExObjType.INTEGER"/> -> returns <see cref="F:ExMat.ExObjVal.i_Int"/> from <see cref="F:ExMat.Objects.ExObject.Value"/>
            <para>Otherwise -> returns <see cref="F:ExMat.ExObjVal.f_Float"/> from <see cref="F:ExMat.Objects.ExObject.Value"/> as integer (unsafe limits)</para></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetFloat">
            <summary>
            Get the float value stored
            </summary>
            <returns>If <see cref="F:ExMat.Objects.ExObject.Type"/> is <see cref="F:ExMat.ExObjType.FLOAT"/> -> returns <see cref="F:ExMat.ExObjVal.f_Float"/> from <see cref="F:ExMat.Objects.ExObject.Value"/>
            <para>Otherwise -> returns <see cref="F:ExMat.ExObjVal.i_Int"/> from <see cref="F:ExMat.Objects.ExObject.Value"/> as float</para></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetComplex">
            <summary>
            Get the complex value stored
            </summary>
            <returns>New <see cref="T:System.Numerics.Complex"/> struct using <see cref="F:ExMat.ExObjVal.f_Float"/> and <see cref="F:ExMat.ExObjVal.c_Float"/> for real and imaginary parts respectively</returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetComplexConj">
            <summary>
            Get the complex value stored conjugated
            </summary>
            <returns>New <see cref="T:System.Numerics.Complex"/> struct using <see cref="F:ExMat.ExObjVal.f_Float"/> and <c>-</c><see cref="F:ExMat.ExObjVal.c_Float"/> for real and imaginary parts respectively</returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetComplexString">
            <summary>
            Get the string represtation of the complex value stored, zero values not used unless both parts are zero => 0i
            </summary>
            <returns>String in format <c>{<see cref="F:ExMat.ExObjVal.f_Float"/>} +/- {<see cref="F:ExMat.ExObjVal.c_Float"/>}i</c></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetString">
            <summary>
            Get string value stored, never returns <see langword="null"/>, uses <see cref="F:System.String.Empty"/> instead.
            </summary>
            <returns>Returns <see cref="F:ExMat.ExObjValCustom.s_String"/></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetWeakRef">
            <summary>
            Gets the weak reference object stored
            </summary>
            <returns>Returns <see cref="F:ExMat.ExObjValCustom._WeakRef"/></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetBool">
            <summary>
            Gets the boolean value of for any type
            </summary>
            <returns>Returns bool represtation of the current value stored for the <see cref="F:ExMat.Objects.ExObject.Type"/></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetDict">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.Dictionary`2"/> stored (&lt;<see cref="T:System.String"/>,<see cref="T:ExMat.Objects.ExObject"/>&gt;)
            </summary>
            <returns>Returns <see cref="F:ExMat.ExObjValCustom.d_Dict"/></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetList">
            <summary>
            Gets the <see cref="T:System.Collections.Generic.List`1"/> stored (&lt;<see cref="T:ExMat.Objects.ExObject"/>&gt;)
            </summary>
            <returns>Returns <see cref="F:ExMat.ExObjValCustom.l_List"/></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetClosure">
            <summary>
            Gets the closure stored
            </summary>
            <returns>Returns <see cref="F:ExMat.ExObjValCustom._Closure"/></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetNClosure">
            <summary>
            Gets the native closure stored
            </summary>
            <returns>Returns <see cref="F:ExMat.ExObjValCustom._NativeClosure"/></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetInstance">
            <summary>
            Gets the instance stored
            </summary>
            <returns>Returns <see cref="F:ExMat.ExObjValCustom._Instance"/></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetClass">
            <summary>
            Gets the class stored
            </summary>
            <returns>Returns <see cref="F:ExMat.ExObjValCustom._Class"/></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetSpace">
            <summary>
            Gets the space object stored
            </summary>
            <returns>Returns <see cref="F:ExMat.ExObjValCustom.c_Space"/></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.Dispose">
            <summary>
            Disposer
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExObject.IsField">
            <summary>
            Wheter this object is a field in an <see cref="T:ExMat.ExClass.ExClass"/> object
            </summary>
            <returns></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.IsMethod">
            <summary>
            Wheter this object is a method in an <see cref="T:ExMat.ExClass.ExClass"/> object
            </summary>
            <returns></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.GetMemberID">
            <summary>
            Get the member index of this object in an <see cref="T:ExMat.ExClass.ExClass"/> object
            </summary>
            <returns></returns>
        </member>
        <member name="M:ExMat.Objects.ExObject.AddReference(ExMat.ExObjType,ExMat.ExObjValCustom,System.Boolean)">
            <summary>
            Increment reference count to this object, can be forced with <paramref name="forced"/> to skip type check, requires <paramref name="t"/> to be reference counting type
            </summary>
            <param name="t">Object type</param>
            <param name="v">Object value storing reference counter</param>
            <param name="forced">Wheter to skip type check</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Release">
            <summary>
            Decrement reference count to this object, if reference count hits <c>0</c>, object will be disposed
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor">
            <summary>
            Null constructor
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(ExMat.Objects.ExObject)">
            <summary>
            Copy and reference to given object
            </summary>
            <param name="other">Object to increment reference of</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(System.Int64)">
            <summary>
            Integer constructor
            </summary>
            <param name="i">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(System.Double)">
            <summary>
            Float constructor
            </summary>
            <param name="f">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(System.Boolean)">
            <summary>
            Bool constructor
            </summary>
            <param name="b">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(System.String)">
            <summary>
            String constructor
            </summary>
            <param name="s">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(System.Numerics.Complex)">
            <summary>
            Complex number constructor
            </summary>
            <param name="cmplx">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(System.Collections.Generic.Dictionary{System.String,ExMat.Objects.ExObject})">
            <summary>
            Dictionary constructor
            </summary>
            <param name="dict">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(System.Collections.Generic.List{ExMat.Objects.ExObject})">
            <summary>
            List constructor
            </summary>
            <param name="lis">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(ExMat.ExClass.ExInstance)">
            <summary>
            Instance constructor
            </summary>
            <param name="inst">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(ExMat.ExClass.ExClass)">
            <summary>
            Class constructor
            </summary>
            <param name="class">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(ExMat.Closure.ExClosure)">
            <summary>
            Closure constructor
            </summary>
            <param name="cls">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(ExMat.Closure.ExNativeClosure)">
            <summary>
            Native closure constructor
            </summary>
            <param name="ncls">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(ExMat.Outer.ExOuter)">
            <summary>
            Outer constructor
            </summary>
            <param name="outer">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(ExMat.Objects.ExWeakRef)">
            <summary>
            Weakreference constructor
            </summary>
            <param name="wref">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(ExMat.FuncPrototype.ExPrototype)">
            <summary>
            Prototype constructor
            </summary>
            <param name="pro">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.#ctor(ExMat.Objects.ExSpace)">
            <summary>
            Space constructor
            </summary>
            <param name="space">Value to store</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(ExMat.Objects.ExObject)">
            <summary>
            Reference to another object, deref current values stored
            </summary>
            <param name="other">Other object</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(System.Int64)">
            <summary>
            Assing integer, deref current values stored
            </summary>
            <param name="i">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(System.Double)">
            <summary>
            Assing float, deref current values stored
            </summary>
            <param name="f">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(System.Boolean)">
            <summary>
            Assing bool, deref current values stored
            </summary>
            <param name="b">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(System.String)">
            <summary>
            Assing string, deref current values stored
            </summary>
            <param name="s">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(System.Numerics.Complex)">
            <summary>
            Assing complex number, deref current values stored
            </summary>
            <param name="cmplx">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(ExMat.Objects.ExSpace)">
            <summary>
            Assing space, deref current values stored
            </summary>
            <param name="space">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(System.Collections.Generic.Dictionary{System.String,ExMat.Objects.ExObject})">
            <summary>
            Assing dictionary, deref current values stored
            </summary>
            <param name="dict">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(System.Collections.Generic.List{ExMat.Objects.ExObject})">
            <summary>
            Assing list, deref current values stored
            </summary>
            <param name="lis">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(ExMat.ExClass.ExInstance)">
            <summary>
            Assing instance, deref current values stored
            </summary>
            <param name="inst">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(ExMat.ExClass.ExClass)">
            <summary>
            Assing class, deref current values stored
            </summary>
            <param name="class">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(ExMat.Closure.ExClosure)">
            <summary>
            Assing closure, deref current values stored
            </summary>
            <param name="cls">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(ExMat.Closure.ExNativeClosure)">
            <summary>
            Assing native closure, deref current values stored
            </summary>
            <param name="ncls">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(ExMat.Outer.ExOuter)">
            <summary>
            Assing outer variable, deref current values stored
            </summary>
            <param name="outer">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(ExMat.FuncPrototype.ExPrototype)">
            <summary>
            Assing prototype, deref current values stored
            </summary>
            <param name="pro">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Assign(ExMat.Objects.ExWeakRef)">
            <summary>
            Assing weak reference, deref current values stored
            </summary>
            <param name="wref">New value</param>
        </member>
        <member name="M:ExMat.Objects.ExObject.Nullify">
            <summary>
            Nullify the object, deref current value
            </summary>
        </member>
        <member name="T:ExMat.Objects.ExRefC">
            <summary>
            Reference counter class
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExRefC.ReferenceCount">
            <summary>
            Reference count
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExRefC.WeakReference">
            <summary>
            Weakly referenced object if any
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExRefC.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExRefC.GetWeakRef(ExMat.ExObjType,ExMat.ExObjVal,ExMat.ExObjValCustom)">
            <summary>
            Get or construct the weak reference object
            </summary>
            <param name="t">If there is no weakref, assign this type</param>
            <param name="v">If there is no weakref, assign this basic value</param>
            <param name="vc">If there is no weakref, assign this custom value</param>
            <returns>Weak reference found or constructed</returns>
        </member>
        <member name="M:ExMat.Objects.ExRefC.Dispose">
            <summary>
            Disposer
            </summary>
        </member>
        <member name="T:ExMat.Objects.ExSpace">
            <summary>
            Space object model
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExSpace.Dimension">
            <summary>
            Dimension
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExSpace.Domain">
            <summary>
            Domain: R, Z, C, E ; Lower case to exclude zero (except for E)
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExSpace.Sign">
            <summary>
            Sign: +, -, \\ (Any)
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExSpace.Child">
            <summary>
            Inner space for extra dimensions
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExSpace.GetString">
            <summary>
            Get string representation
            </summary>
            <returns></returns>
        </member>
        <member name="M:ExMat.Objects.ExSpace.#ctor">
            <summary>
            Empty constructor
            </summary>
        </member>
        <member name="M:ExMat.Objects.ExSpace.#ctor(System.Int32,System.String,System.Char,ExMat.Objects.ExSpace)">
            <summary>
            Space with given dimension, domain, sign and inner space
            </summary>
            <param name="dim">Dimension</param>
            <param name="dom">Domain</param>
            <param name="sign">Sign</param>
            <param name="ch">Extras</param>
        </member>
        <member name="M:ExMat.Objects.ExSpace.#ctor(System.String,System.Int32,System.Char)">
            <summary>
            Space with given domain, dimension, sign
            </summary>
            <param name="spc">Domain</param>
            <param name="d">Dimension</param>
            <param name="s">Sign</param>
        </member>
        <member name="M:ExMat.Objects.ExSpace.AddDimension(ExMat.Objects.ExSpace)">
            <summary>
            Add given space as dimension
            </summary>
            <param name="ch"></param>
        </member>
        <member name="M:ExMat.Objects.ExSpace.Create(System.String,System.Char,System.Int32[])">
            <summary>
            Return a new space instance with given values
            </summary>
            <param name="spc"></param>
            <param name="s"></param>
            <param name="dims"></param>
            <returns></returns>
        </member>
        <member name="M:ExMat.Objects.ExSpace.GetSpaceString">
            <summary>
            Get informational string represtation
            </summary>
            <returns></returns>
        </member>
        <member name="M:ExMat.Objects.ExSpace.Copy(ExMat.Objects.ExSpace,ExMat.Objects.ExSpace)">
            <summary>
            Get a copy of the given space
            </summary>
            <param name="to">Destination</param>
            <param name="from">Source</param>
        </member>
        <member name="M:ExMat.Objects.ExSpace.DeepCopy">
            <summary>
            Get a new and exact copy of the space
            </summary>
            <returns></returns>
        </member>
        <member name="T:ExMat.Objects.ExWeakRef">
            <summary>
            Weak reference object
            </summary>
        </member>
        <member name="F:ExMat.Objects.ExWeakRef.ReferencedObject">
            <summary>
            Weakly refernced object
            </summary>
        </member>
        <member name="T:ExMat.States.ExFState">
            <summary>
            Function state tracking for compiler
            </summary>
        </member>
        <member name="F:ExMat.States.ExFState.SharedState">
            <summary>
            Shared state
            </summary>
        </member>
        <member name="F:ExMat.States.ExFState.Source">
            <summary>
            Source code
            </summary>
        </member>
        <member name="F:ExMat.States.ExFState.Name">
            <summary>
            Current closure's name
            </summary>
        </member>
        <member name="F:ExMat.States.ExFState.Literals">
            <summary>
            Literals and objects storing the literals
            </summary>
        </member>
        <member name="F:ExMat.States.ExFState.nLiterals">
            <summary>
            Literals count
            </summary>
        </member>
        <member name="F:ExMat.States.ExFState.LocalVariables">
            <summary>
            Local variable information
            </summary>
        </member>
        <member name="T:ExMat.States.ExSState">
            <summary>
            Shared state model to keep track of common values
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.Root">
            <summary>
            Owner VM
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.MetaMethods">
            <summary>
            List of meta method names
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.MetaMethodsMap">
            <summary>
            Meta method names mapped to <see cref="T:ExMat.ExMetaMethod"/> integer values
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.ConstructorID">
            <summary>
            Class constructor method name
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.Strings">
            <summary>
            String literals and the objects they are stored in
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.Consts">
            <summary>
            Constant names and their values
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.ClassDelegate">
            <summary>
            <see cref="F:ExMat.ExObjType.CLASS"/> type object delegates
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.DictDelegate">
            <summary>
            <see cref="F:ExMat.ExObjType.DICT"/> type object delegates
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.ListDelegate">
            <summary>
            <see cref="F:ExMat.ExObjType.ARRAY"/> type object delegates
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.ComplexDelegate">
            <summary>
            <see cref="F:ExMat.ExObjType.COMPLEX"/> type object delegates
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.NumberDelegate">
            <summary>
            <see cref="F:ExMat.ExObjType.INTEGER"/> or <see cref="F:ExMat.ExObjType.FLOAT"/> type object delegates
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.StringDelegate">
            <summary>
            <see cref="F:ExMat.ExObjType.STRING"/> type object delegates
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.ClosureDelegate">
            <summary>
            <see cref="F:ExMat.ExObjType.CLOSURE"/> type object delegates
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.InstanceDelegate">
            <summary>
            <see cref="F:ExMat.ExObjType.INSTANCE"/> type object delegates
            </summary>
        </member>
        <member name="F:ExMat.States.ExSState.WeakRefDelegate">
            <summary>
            <see cref="F:ExMat.ExObjType.WEAKREF"/> type object delegates
            </summary>
        </member>
        <member name="M:ExMat.States.ExSState.Initialize">
            <summary>
            Initialize the shared state
            </summary>
        </member>
        <member name="M:ExMat.States.ExSState.GetMetaIdx(System.String)">
            <summary>
            Get meta method index from it's name
            </summary>
            <param name="mname">Meta method name</param>
            <returns></returns>
        </member>
        <member name="M:ExMat.States.ExSState.Dispose">
            <summary>
            Disposer
            </summary>
        </member>
        <member name="T:ExMat.OPs.BitOP">
            <summary>
            Bitwise operations
            </summary>
        </member>
        <member name="F:ExMat.OPs.BitOP.AND">
            <summary>
            Bitwise and
            </summary>
        </member>
        <member name="F:ExMat.OPs.BitOP.OR">
            <summary>
            Bitwise or
            </summary>
        </member>
        <member name="F:ExMat.OPs.BitOP.XOR">
            <summary>
            Bitwise xor
            </summary>
        </member>
        <member name="F:ExMat.OPs.BitOP.SHIFTL">
            <summary>
            Bit shift left
            </summary>
        </member>
        <member name="F:ExMat.OPs.BitOP.SHIFTR">
            <summary>
            Bit shift right
            </summary>
        </member>
        <member name="T:ExMat.OPs.CmpOP">
            <summary>
            Comparison operations
            </summary>
        </member>
        <member name="F:ExMat.OPs.CmpOP.GRT">
            <summary>
            Greater  than
            </summary>
        </member>
        <member name="F:ExMat.OPs.CmpOP.GET">
            <summary>
            Greater or equal than
            </summary>
        </member>
        <member name="F:ExMat.OPs.CmpOP.LST">
            <summary>
            Less than
            </summary>
        </member>
        <member name="F:ExMat.OPs.CmpOP.LET">
            <summary>
            Less or equal than
            </summary>
        </member>
        <member name="T:ExMat.OPs.ExOperationCode">
            <summary>
            Operation codes for the VM
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.LOADINTEGER">
            <summary>
            Load integer to stack
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.LOADFLOAT">
            <summary>
            Load float to stack
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.LOADBOOLEAN">
            <summary>
            Load boolean to stack
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.LOADCOMPLEX">
            <summary>
            Load complex number to stack
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.LOADSPACE">
            <summary>
            Load space to stack
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.EQ">
            <summary>
            Check equal
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.NEQ">
            <summary>
            Check not equal
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.CMP">
            <summary>
            Compare
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.JCMP">
            <summary>
            Conditional jump
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.JMP">
            <summary>
            Jump
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.JZ">
            <summary>
            Conditional jump (on zero)
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.CALL">
            <summary>
            Call the object
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.PREPCALL">
            <summary>
            Prepare stack for a call
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.PREPCALLK">
            <summary>
            Prepare stack for a call with outers
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.CALLTAIL">
            <summary>
            Tail call
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.LOAD">
            <summary>
            Load literal to stack
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.DLOAD">
            <summary>
            Double load literal to stack
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.GET">
            <summary>
            Get known variable or member
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.GETK">
            <summary>
            Get unknown variable or member
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.MOVE">
            <summary>
            Move object in stack
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.DMOVE">
            <summary>
            Double move objects in stack
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.SET">
            <summary>
            Call object's setter
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.DELETE">
            <summary>
            Delete a slot from object
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.CLOSURE">
            <summary>
            Create a closure
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.EXISTS">
            <summary>
            Check existance of value in another
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.INSTANCEOF">
            <summary>
            Instancing check
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.TYPEOF">
            <summary>
            Get type of object
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.RETURN">
            <summary>
            Return object from frame
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.APPENDTOARRAY">
            <summary>
            Append value to a list
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.LOADNULL">
            <summary>
            Nullify object in stack
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.LOADROOT">
            <summary>
            Push root table to stack
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.SETOUTER">
            <summary>
            Set outer value
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.GETOUTER">
            <summary>
            Get outer value
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.NEWOBJECT">
            <summary>
            Create new object
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.NEWSLOT">
            <summary>
            Create a new slot in an object
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.NEWSLOTA">
            <summary>
            Create an attribute
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.COMPOUNDARITH">
            <summary>
            Compound arithmetic
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.MOD">
            <summary>
            Modulo opertaion
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.INC">
            <summary>
            Increment, no return
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.PINC">
            <summary>
            Increment and return
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.INCL">
            <summary>
            Increment variable, no return
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.PINCL">
            <summary>
            Increment variable and return
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.MLT">
            <summary>
            Multiplication operation
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.ADD">
            <summary>
            Addition operation
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.LINE">
            <summary>
            Line tracking
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.SUB">
            <summary>
            Subtraction operation
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.BITWISE">
            <summary>
            Bitwise operation
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.DIV">
            <summary>
            Division operation
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.EXP">
            <summary>
            Exponential operation
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.AND">
            <summary>
            Logic and operation
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.OR">
            <summary>
            Logic or operation
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.NEGATE">
            <summary>
            Negate object
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.NOT">
            <summary>
            Logic not operation
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.BNOT">
            <summary>
            Bitwise not operation
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.GETBASE">
            <summary>
            Get base object
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.RETURNBOOL">
            <summary>
            Return value as boolean
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.MMLT">
            <summary>
            Matrix multiplication
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.TRANSPOSE">
            <summary>
            Transpose operation
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.CARTESIAN">
            <summary>
            Cartesian product
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.DEFAULT">
            <summary>
            Load parameter's default value
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.LOADCONSTDICT">
            <summary>
            Load constants dictionary to stack
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.RELOADLIB">
            <summary>
            Reload a standard library
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.FOREACH">
            <summary>
            Foreach loop
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.POSTFOREACH">
            <summary>
            Post foreach for generators
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExOperationCode.CLOSE">
            <summary>
            Outer variable control end
            </summary>
        </member>
        <member name="T:ExMat.OPs.ExNewObjectType">
            <summary>
            New object type
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExNewObjectType.DICT">
            <summary>
            Dictionary
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExNewObjectType.ARRAY">
            <summary>
            List
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExNewObjectType.CLASS">
            <summary>
            Class
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExNewObjectType.RULE">
            <summary>
            Rule
            </summary>
        </member>
        <member name="T:ExMat.OPs.ArrayAType">
            <summary>
            Array value append type
            </summary>
        </member>
        <member name="F:ExMat.OPs.ArrayAType.INVALID">
            <summary>
            Unknown
            </summary>
        </member>
        <member name="F:ExMat.OPs.ArrayAType.STACK">
            <summary>
            From stack
            </summary>
        </member>
        <member name="F:ExMat.OPs.ArrayAType.LITERAL">
            <summary>
            String
            </summary>
        </member>
        <member name="F:ExMat.OPs.ArrayAType.INTEGER">
            <summary>
            Integer
            </summary>
        </member>
        <member name="F:ExMat.OPs.ArrayAType.FLOAT">
            <summary>
            Float
            </summary>
        </member>
        <member name="F:ExMat.OPs.ArrayAType.BOOL">
            <summary>
            Boolean
            </summary>
        </member>
        <member name="T:ExMat.OPs.ExNewSlotFlag">
            <summary>
            New slot operation flags
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExNewSlotFlag.ATTR">
            <summary>
            Is attribute ?
            </summary>
        </member>
        <member name="F:ExMat.OPs.ExNewSlotFlag.STATIC">
            <summary>
            Is static ?
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer._source">
            <summary>
            Source code
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer._source_idx">
            <summary>
            Current reading index of <see cref="F:ExMat.Lexer.ExLexer._source"/>
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer._source_len">
            <summary>
            Length of source code <see cref="F:ExMat.Lexer.ExLexer._source"/>
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer.CurrentLine">
            <summary>
            Line count
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer.PrevTokenLine">
            <summary>
            Last line number a token was found
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer.CurrentCol">
            <summary>
            Current column index
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer.CurrentChar">
            <summary>
            Last character read
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer.TokenPrev">
            <summary>
            Previous token found
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer.TokenCurr">
            <summary>
            Last token found
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer.ValInteger">
            <summary>
            Currently read integer value
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer.ValFloat">
            <summary>
            Currently read float value
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer.ValString">
            <summary>
            Currently read string value
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer.ValSpace">
            <summary>
            Currently read space value
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer.ValTempString">
            <summary>
            Temporary string builder while reading strings
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer.TokenComplex">
            <summary>
            Type of the currently read complex number's real part, either <see cref="F:ExMat.Token.TokenType.INTEGER"/> or <see cref="F:ExMat.Token.TokenType.FLOAT"/>
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer.ErrorString">
            <summary>
            Error message
            </summary>
        </member>
        <member name="F:ExMat.Lexer.ExLexer.KeyWords">
            <summary>
            Keywords dictionary
            </summary>
        </member>
        <member name="T:ExMat.ExMat">
            <summary>
            Definitions of commonly used constants
            </summary>
        </member>
        <member name="F:ExMat.ExMat.Version">
            <summary>
            Full version
            </summary>
        </member>
        <member name="F:ExMat.ExMat.VersionNumber">
            <summary>
            Version number
            </summary>
        </member>
        <member name="F:ExMat.ExMat.ConsoleTitle">
            <summary>
            Title of the interactive console
            </summary>
        </member>
        <member name="F:ExMat.ExMat.HelpInfoString">
            <summary>
            Help information to print at the beginning
            </summary>
        </member>
        <member name="F:ExMat.ExMat.CANCELKEYTHREADTIMER">
            <summary>
            Time in ms to delay output so CTRL+C doesn't mess up
            </summary>
        </member>
        <member name="F:ExMat.ExMat.EndChar">
            <summary>
            String and file terminator character
            </summary>
        </member>
        <member name="F:ExMat.ExMat.ConstructorName">
            <summary>
            Constructor method name for classes
            </summary>
        </member>
        <member name="F:ExMat.ExMat.BaseName">
            <summary>
            Base reference keyword name
            </summary>
        </member>
        <member name="F:ExMat.ExMat.ThisName">
            <summary>
            Self reference keyword name
            </summary>
        </member>
        <member name="F:ExMat.ExMat.FuncName">
            <summary>
            Function attribute, returns name of the function
            </summary>
        </member>
        <member name="F:ExMat.ExMat.HelpName">
            <summary>
            Function attribute, returns the documentation about the function
            </summary>
        </member>
        <member name="F:ExMat.ExMat.DocsName">
            <summary>
            Function attribute, returns the summary of the function
            </summary>
        </member>
        <member name="F:ExMat.ExMat.ReturnsName">
            <summary>
            Function attribute, returns the return type information string
            </summary>
        </member>
        <member name="F:ExMat.ExMat.NullName">
            <summary>
            String representation of a null value
            </summary>
        </member>
        <member name="F:ExMat.ExMat.ForeachSingleIdxName">
            <summary>
            Foreach single index variable name
            </summary>
        </member>
        <member name="F:ExMat.ExMat.ForeachIteratorName">
            <summary>
            Foreach single index variable name
            </summary>
        </member>
        <member name="F:ExMat.ExMat.VargsName">
            <summary>
            Variable parameter count functions' argument list keyword name
            <para>Example function where this is available: <see langword="function"/><c> Foo(...){}</c></para>
            </summary>
        </member>
        <member name="F:ExMat.ExMat.DelegName">
            <summary>
            Function attribute, returns wheter the function is a delegate function
            </summary>
        </member>
        <member name="F:ExMat.ExMat.InvalidArgument">
            <summary>
            INTERNAL: Used to check for some special cases
            </summary>
        </member>
        <member name="F:ExMat.ExMat.SequenceParameter">
            <summary>
            Default parameter name for sequences
            </summary>
        </member>
        <member name="F:ExMat.ExMat.nParams">
            <summary>
            Function attribute, returns named parameter count
            </summary>
        </member>
        <member name="F:ExMat.ExMat.nDefParams">
            <summary>
            Function attribute, returns default valued parameter count
            </summary>
        </member>
        <member name="F:ExMat.ExMat.nMinArgs">
            <summary>
            Function attribute, returns minimum amount of arguments required
            </summary>
        </member>
        <member name="F:ExMat.ExMat.DefParams">
            <summary>
            Function attribute, returns dictionary of default values for parameters
            </summary>
        </member>
        <member name="F:ExMat.ExMat.ReloadFunc">
            <summary>
            Function name, reload a function 
            </summary>
        </member>
        <member name="F:ExMat.ExMat.ReloadLibFunc">
            <summary>
            Function name, reload a standard library specific function
            </summary>
        </member>
        <member name="F:ExMat.ExMat.ReloadName">
            <summary>
            Library reloading keyword name
            </summary>
        </member>
        <member name="F:ExMat.ExMat.ECHOLIMIT">
            <summary>
            Maximum length of the echo'd string, used for native functions which calls 'echo' in external terminals
            </summary>
        </member>
        <member name="F:ExMat.ExMat.GCCOLLECTCOUNT">
            <summary>
            Garbage collection run count after execution
            </summary>
        </member>
        <member name="F:ExMat.ExMat.DateTypeInfoString">
            <summary>
            Informational multi-line string about available types for 'date' function
            </summary>
        </member>
        <member name="F:ExMat.ExMat.TypeMasks">
            <summary>
            Type mask information
            <para>  Integer   |   Mask     |   Expected Type</para>
            <para>-------------------------------------</para>
            <para>   -1       |    .       |   Any type</para>
            <para>    0       |    .       |   Any type</para>
            <para>    1       |    e       |   NULL</para>
            <para>    2       |    i       |   INTEGER</para>
            <para>    4       |    f       |   FLOAT</para>
            <para>    8       |    C       |   COMPLEX</para>
            <para>    16      |    b       |   BOOL</para>
            <para>    32      |    s       |   STRING</para>
            <para>    64      |    S       |   SPACE</para>
            <para>    128     |    a       |   ARRAY</para>
            <para>    256     |    d       |   DICT</para>
            <para>    512     |    f       |   CLOSURE</para>
            <para>    1024    |    Y       |   NATIVECLOSURE</para>
            <para>    2048    |    y       |   CLASS</para>
            <para>    4096    |    x       |   INSTANCE</para>
            <para>    8192    |    w       |   WEAKREF</para>
            <para>    6       |    r       |   INTEGER|FLOAT</para>
            <para>    14      |    n       |   INTEGER|FLOAT|COMPLEX</para>
            <para>    1536    |    c       |   CLOSURE|NATIVECLOSURE</para>
            </summary>
        </member>
        <member name="F:ExMat.ExMat.StandardBaseLibraryName">
            <summary>
            Standard base library name
            </summary>
        </member>
        <member name="F:ExMat.ExMat.StandardLibraryNameSpace">
            <summary>
            Namespace required for a class to be checked for being a standard library 
            </summary>
        </member>
        <member name="T:ExMat.ExMat.StdLibRegistery">
            <summary>
            Delegate registery method for std libs
            </summary>
            <param name="vm">Virtual machine for registery</param>
            <returns><see langword="true"/> if registery was successful, otherwise <see langword="false"/></returns>
        </member>
        <member name="T:ExMat.ExMat.StdLibFunction">
            <summary>
            Delegate, a native function template
            </summary>
            <param name="vm">VM to use the stack of</param>
            <param name="nargs">Number of arguments passed to the function</param>
            <returns>If a value was pushed to stack: <see cref="F:ExMat.ExFunctionStatus.SUCCESS"/>
            <para>If nothing was pushed to stack: <see cref="F:ExMat.ExFunctionStatus.VOID"/></para>
            <para>If there was an error: <see cref="F:ExMat.ExFunctionStatus.ERROR"/></para>
            <para>In the special case of 'exit': <see cref="F:ExMat.ExFunctionStatus.EXIT"/></para></returns>
        </member>
        <member name="T:ExMat.ExMat.PrinterMethod">
            <summary>
            Printer method delegate, no line terminator at the end
            </summary>
            <param name="message">Message to print</param>
        </member>
        <member name="T:ExMat.ExMat.LineReaderMethod">
            <summary>
            Input line reader method delegate
            </summary>
            <returns>Line read</returns>
        </member>
        <member name="T:ExMat.ExMat.KeyReaderMethod">
            <summary>
            Input key reader method delegate
            </summary>
            <returns>Key read</returns>
        </member>
        <member name="T:ExMat.ExMat.IntKeyReaderMethod">
            <summary>
            Input key reader method delegate
            </summary>
            <returns>Key read as integer</returns>
        </member>
        <member name="F:ExMat.ExMat.StdLibFunctionPatternMethodName">
            <summary>
            Method name of delegate <see cref="T:ExMat.ExMat.StdLibFunction"/> to get standard library method signature pattern from
            </summary>
        </member>
        <member name="P:ExMat.ExMat.StdLibFunctionPattern">
            <summary>
            Standard library method signature pattern, this is for matching <see cref="T:ExMat.ExMat.StdLibFunction"/>'s signature
            </summary>
        </member>
        <member name="T:ExMat.ExMat.ExAssemblyType">
            <summary>
            Assembly type to decide wheter to load directly or from a file
            </summary>
        </member>
        <member name="F:ExMat.ExMat.ExAssemblyType.NATIVE">
            <summary>
            Built-in assembly
            </summary>
        </member>
        <member name="F:ExMat.ExMat.ExAssemblyType.PLUGIN">
            <summary>
            External plugin
            </summary>
        </member>
        <member name="F:ExMat.ExMat.StdLibFunctionRegex">
            <summary>
            Regex object to use while finding standard library functions
            </summary>
        </member>
        <member name="F:ExMat.ExMat.ConsoleFlags">
            <summary>
            Expected names for the console flags
            <para>Don't display information banner: <code>--no-info</code></para>
            <para>Don't use custom console title: <code>--no-title</code></para>
            <para>Don't wait post exit: <code>--no-exit-hold</code></para>
            <para>Don't write IN and OUT prefix: <code>--no-inout</code></para>
            <para>Delete the given file post execution: <code>--delete-onpost</code></para>
            <para>Print help string: <code>--help</code></para>
            </summary>
        </member>
        <member name="F:ExMat.ExMat.ConsoleParameters">
            <summary>
            Expected names for the console flags. Make <see cref="T:ExMat.ExConsoleParameter"/> invoke return <see langword="null"/> to keep the parameter in the referenced array
            <para>Custom stack size: <code>-stacksize:"?(.*)"?</code></para>
            <para>Custom console title: <code>-title:"?(.*)"?</code></para>
            <para>Plugin library path: <code>-plugin:"?(.*)"?</code></para>
            </summary>
        </member>
        <member name="T:ExMat.ExBaseType">
            <summary>
            Base/raw object types, use one of these to create <see cref="T:ExMat.ExObjType"/> types with <see cref="T:ExMat.ExObjFlag"/> flags
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.NULL">
            <summary>
            null value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.INTEGER">
            <summary>
            Integer value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.FLOAT">
            <summary>
            Float value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.COMPLEX">
            <summary>
            Complex value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.BOOL">
            <summary>
            Boolean value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.STRING">
            <summary>
            String value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.SPACE">
            <summary>
            Space value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.ARRAY">
            <summary>
            Array value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.DICT">
            <summary>
            Dictionary value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.CLOSURE">
            <summary>
            Closure value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.NATIVECLOSURE">
            <summary>
            Native closure value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.CLASS">
            <summary>
            Class value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.INSTANCE">
            <summary>
            Instance value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.WEAKREF">
            <summary>
            Weak reference value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.DEFAULT">
            <summary>
            Default value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.OUTER">
            <summary>
            INTERNAL: Outer value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.FUNCPRO">
            <summary>
            INTERNAL: Function prototype value
            </summary>
        </member>
        <member name="F:ExMat.ExBaseType.GENERATOR">
            <summary>
            Generator
            </summary>
        </member>
        <member name="T:ExMat.ExObjFlag">
            <summary>
            Object type flags for <see cref="T:ExMat.ExObjType"/> types, used to define how a type should be treated
            </summary>
        </member>
        <member name="F:ExMat.ExObjFlag.CANBEFALSE">
            <summary>
            Allow to be used as a <see langword="false"/> value in certain cases(defined in comparison methods)
            </summary>
        </member>
        <member name="F:ExMat.ExObjFlag.NUMERIC">
            <summary>
            A numeric type
            </summary>
        </member>
        <member name="F:ExMat.ExObjFlag.COUNTREFERENCES">
            <summary>
            Keep track of references made to this
            </summary>
        </member>
        <member name="F:ExMat.ExObjFlag.HASDELEGATES">
            <summary>
            Allow access delegate methods
            </summary>
        </member>
        <member name="T:ExMat.ExObjType">
            <summary>
            Available object types for <see cref="T:ExMat.Objects.ExObject"/> objects
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.NULL">
            <summary>
            null value object
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.INTEGER">
            <summary>
            Integer value object
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.FLOAT">
            <summary>
            Float value object
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.COMPLEX">
            <summary>
            Complex value object
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.BOOL">
            <summary>
            Bool value object
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.STRING">
            <summary>
            String value object
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.SPACE">
            <summary>
            Space value object
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.ARRAY">
            <summary>
            Array object
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.DICT">
            <summary>
            Dictionary object
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.CLOSURE">
            <summary>
            Closure object
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.NATIVECLOSURE">
            <summary>
            Native closure object
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.CLASS">
            <summary>
            Class object
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.INSTANCE">
            <summary>
            Instance object
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.WEAKREF">
            <summary>
            Weak reference
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.GENERATOR">
            <summary>
            Generator
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.DEFAULT">
            <summary>
            Default value placer for ".." token
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.FUNCPRO">
            <summary>
            INTERNAL: Function prototype
            </summary>
        </member>
        <member name="F:ExMat.ExObjType.OUTER">
            <summary>
            INTERNAL: Outer value
            </summary>
        </member>
        <member name="T:ExMat.DoubleLong">
            <summary>
            Change between 64bit integer and 64bit floats
            </summary>
        </member>
        <member name="F:ExMat.DoubleLong.f">
            <summary>
            Float value
            </summary>
        </member>
        <member name="F:ExMat.DoubleLong.i">
            <summary>
            Integer value
            </summary>
        </member>
        <member name="T:ExMat.ExObjValCustom">
            <summary>
            Custom type(plus <see cref="T:System.String"/>) values stored for <see cref="T:ExMat.Objects.ExObject"/> objects
            </summary>
        </member>
        <member name="F:ExMat.ExObjValCustom.s_String">
            <summary>
            String value for <see cref="F:ExMat.ExObjType.STRING"/>
            </summary>
        </member>
        <member name="F:ExMat.ExObjValCustom.l_List">
            <summary>
            Array for <see cref="F:ExMat.ExObjType.ARRAY"/>
            </summary>
        </member>
        <member name="F:ExMat.ExObjValCustom.d_Dict">
            <summary>
            Dictionary for <see cref="F:ExMat.ExObjType.DICT"/>
            </summary>
        </member>
        <member name="F:ExMat.ExObjValCustom.c_Space">
            <summary>
            Space value for <see cref="F:ExMat.ExObjType.SPACE"/>
            </summary>
        </member>
        <member name="F:ExMat.ExObjValCustom._Closure">
            <summary>
            Closure for <see cref="F:ExMat.ExObjType.CLOSURE"/>
            </summary>
        </member>
        <member name="F:ExMat.ExObjValCustom._NativeClosure">
            <summary>
            Native closure for <see cref="F:ExMat.ExObjType.NATIVECLOSURE"/>
            </summary>
        </member>
        <member name="F:ExMat.ExObjValCustom._Class">
            <summary>
            Class for <see cref="F:ExMat.ExObjType.CLASS"/>
            </summary>
        </member>
        <member name="F:ExMat.ExObjValCustom._Instance">
            <summary>
            Instance for <see cref="F:ExMat.ExObjType.INSTANCE"/>
            </summary>
        </member>
        <member name="F:ExMat.ExObjValCustom._WeakRef">
            <summary>
            Weak reference for <see cref="F:ExMat.ExObjType.WEAKREF"/>
            </summary>
        </member>
        <member name="F:ExMat.ExObjValCustom._RefC">
            <summary>
            INTERNAL: Reference counter to keep track of references
            </summary>
        </member>
        <member name="F:ExMat.ExObjValCustom._Outer">
            <summary>
            INTERNAL: Outer value for <see cref="F:ExMat.ExObjType.OUTER"/>
            </summary>
        </member>
        <member name="F:ExMat.ExObjValCustom._FuncPro">
            <summary>
            INTERNAL: Function prototype value for <see cref="F:ExMat.ExObjType.FUNCPRO"/>
            </summary>
        </member>
        <member name="T:ExMat.ExObjVal">
            <summary>
            .NET type values stored for <see cref="T:ExMat.Objects.ExObject"/> objects
            </summary>
        </member>
        <member name="F:ExMat.ExObjVal.b_Bool">
            <summary>
            Boolean value for <see cref="F:ExMat.ExObjType.BOOL"/>
            </summary>
        </member>
        <member name="F:ExMat.ExObjVal.i_Int">
            <summary>
            Integer value for <see cref="F:ExMat.ExObjType.INTEGER"/>
            </summary>
        </member>
        <member name="F:ExMat.ExObjVal.f_Float">
            <summary>
            Float value for <see cref="F:ExMat.ExObjType.FLOAT"/>, also stores real part of <see cref="F:ExMat.ExObjType.COMPLEX"/>
            </summary>
        </member>
        <member name="F:ExMat.ExObjVal.c_Float">
            <summary>
            Imaginary part value for <see cref="F:ExMat.ExObjType.COMPLEX"/>
            </summary>
        </member>
        <member name="T:ExMat.ExStdLibType">
            <summary>
            Types for standard libraries
            </summary>
        </member>
        <member name="F:ExMat.ExStdLibType.UNKNOWN">
            <summary>
            Unknown library, for internal use only
            </summary>
        </member>
        <member name="F:ExMat.ExStdLibType.EXTERNAL">
            <summary>
            External custom library
            </summary>
        </member>
        <member name="F:ExMat.ExStdLibType.BASE">
            <summary>
            Base library
            </summary>
        </member>
        <member name="F:ExMat.ExStdLibType.MATH">
            <summary>
            Math library
            </summary>
        </member>
        <member name="F:ExMat.ExStdLibType.IO">
            <summary>
            Input-output library
            </summary>
        </member>
        <member name="F:ExMat.ExStdLibType.STRING">
            <summary>
            String library
            </summary>
        </member>
        <member name="F:ExMat.ExStdLibType.NETWORK">
            <summary>
            Networking library
            </summary>
        </member>
        <member name="F:ExMat.ExStdLibType.SYSTEM">
            <summary>
            System library
            </summary>
        </member>
        <member name="F:ExMat.ExStdLibType.STATISTICS">
            <summary>
            Statistics library
            </summary>
        </member>
        <member name="T:ExMat.ExMetaMethod">
            <summary>
            Meta methods
            <para>Meta methods' names are derived from this enum class as<code>ENUMVAL -&gt; function _ENUMVAL(...)</code></para>
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.ADD">
            <summary>
            Addition ( other )
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.SUB">
            <summary>
            Subtraction ( other )
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.MLT">
            <summary>
            Multiplication ( other )
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.DIV">
            <summary>
            Division ( other )
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.EXP">
            <summary>
            Exponential ( other )
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.MOD">
            <summary>
            Modulo ( other )
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.NEG">
            <summary>
            Negate ( )
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.SET">
            <summary>
            Setter ( key, value )
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.GET">
            <summary>
            Getter ( key )
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.TYPEOF">
            <summary>
            typeof ( )
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.NEXT">
            <summary>
            WIP
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.COMPARE">
            <summary>
            WIP
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.CALL">
            <summary>
            WIP
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.NEWSLOT">
            <summary>
            WIP
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.DELSLOT">
            <summary>
            WIP
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.NEWMEMBER">
            <summary>
            WIP
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.INHERIT">
            <summary>
            WIP
            </summary>
        </member>
        <member name="F:ExMat.ExMetaMethod.STRING">
            <summary>
            WIP
            </summary>
        </member>
        <member name="T:ExMat.ExFunctionStatus">
            <summary>
            Return status of native functions
            </summary>
        </member>
        <member name="F:ExMat.ExFunctionStatus.ERROR">
            <summary>
            An error occured
            </summary>
        </member>
        <member name="F:ExMat.ExFunctionStatus.VOID">
            <summary>
            Nothing is returned
            </summary>
        </member>
        <member name="F:ExMat.ExFunctionStatus.SUCCESS">
            <summary>
            Return value pushed to stack
            </summary>
        </member>
        <member name="F:ExMat.ExFunctionStatus.EXIT">
            <summary>
            Special case: 'exit' function called, closes the interactive console. 
            </summary>
        </member>
        <member name="T:ExMat.ExGetterStatus">
            <summary>
            Getter method status
            </summary>
        </member>
        <member name="F:ExMat.ExGetterStatus.ERROR">
            <summary>
            Base object had issues
            </summary>
        </member>
        <member name="F:ExMat.ExGetterStatus.FOUND">
            <summary>
            Object was found in base object
            </summary>
        </member>
        <member name="F:ExMat.ExGetterStatus.NOTFOUND">
            <summary>
            Object was not found in base object
            </summary>
        </member>
        <member name="T:ExMat.ExSetterStatus">
            <summary>
            Getter method status
            </summary>
        </member>
        <member name="F:ExMat.ExSetterStatus.ERROR">
            <summary>
            Base object had issues
            </summary>
        </member>
        <member name="F:ExMat.ExSetterStatus.SET">
            <summary>
            Setter succeeded
            </summary>
        </member>
        <member name="F:ExMat.ExSetterStatus.NOTSETDELEGATE">
            <summary>
            A delegate was tried to be set
            </summary>
        </member>
        <member name="F:ExMat.ExSetterStatus.NOTSETUNKNOWN">
            <summary>
            Unknown index or delegate tried to be set
            </summary>
        </member>
        <member name="T:ExMat.ExErrorType">
            <summary>
            Error types used for messages
            </summary>
        </member>
        <member name="F:ExMat.ExErrorType.DEFAULT">
            <summary>
            INTERNAL: No overrides on error type, used for handling post-interruption
            </summary>
        </member>
        <member name="F:ExMat.ExErrorType.INTERNAL">
            <summary>
            INTERNAL: Duh
            </summary>
        </member>
        <member name="F:ExMat.ExErrorType.COMPILE">
            <summary>
            Compiler error
            </summary>
        </member>
        <member name="F:ExMat.ExErrorType.RUNTIME">
            <summary>
            Runtime-execution error
            </summary>
        </member>
        <member name="F:ExMat.ExErrorType.INTERRUPT">
            <summary>
            Interruption by CTRLC or CTRLBREAK
            </summary>
        </member>
        <member name="F:ExMat.ExErrorType.INTERRUPTINPUT">
            <summary>
            Interruption of input stream by CTRLC or CTRLBREAK
            </summary>
        </member>
        <member name="T:ExMat.ExConsoleFlag">
            <summary>
            Console flags
            </summary>
        </member>
        <member name="F:ExMat.ExConsoleFlag.DONTKEEPOPEN">
            <summary>
            Don't read key input on exit
            </summary>
        </member>
        <member name="F:ExMat.ExConsoleFlag.NOTITLE">
            <summary>
            Don't use custom console title
            </summary>
        </member>
        <member name="F:ExMat.ExConsoleFlag.NOINOUT">
            <summary>
            Don't print In and Out
            </summary>
        </member>
        <member name="F:ExMat.ExConsoleFlag.DELETEONPOST">
            <summary>
            Wheter to delete file read after attempting to execute
            </summary>
        </member>
        <member name="F:ExMat.ExConsoleFlag.NOINFO">
            <summary>
            Don't print version information
            </summary>
        </member>
        <member name="F:ExMat.ExConsoleFlag.HELP">
            <summary>
            Short console help
            </summary>
        </member>
        <member name="T:ExMat.ExConsoleParameter">
            <summary>
            Delegate for methods to process console parameters
            </summary>
            <param name="arg">Argument to process</param>
            <returns>Numeric, bool or string value</returns>
        </member>
        <member name="T:ExMat.ExInteractiveConsoleFlag">
            <summary>
            Interactive console flags
            </summary>
        </member>
        <member name="F:ExMat.ExInteractiveConsoleFlag.EMPTYINPUT">
            <summary>
            User input was empty
            </summary>
        </member>
        <member name="F:ExMat.ExInteractiveConsoleFlag.LINECARRY">
            <summary>
            Multi-line code state
            </summary>
        </member>
        <member name="F:ExMat.ExInteractiveConsoleFlag.CANCELEVENT">
            <summary>
            Prevented CTRL+C or CTRL+BREAK
            </summary>
        </member>
        <member name="F:ExMat.ExInteractiveConsoleFlag.CURRENTLYEXECUTING">
            <summary>
            Is the active VM currently in the execution process ?
            </summary>
        </member>
        <member name="F:ExMat.ExInteractiveConsoleFlag.RECENTLYINTERRUPTED">
            <summary>
            Has the VM just been interrupted ?
            </summary>
        </member>
        <member name="F:ExMat.ExInteractiveConsoleFlag.INTERRUPTEDINSLEEP">
            <summary>
            Did the recent interruption occured during the thread's sleep ?
            </summary>
        </member>
        <member name="F:ExMat.ExInteractiveConsoleFlag.DONTPRINTOUTPREFIX">
            <summary>
            Wheter to block printing OUT[n] prefix
            </summary>
        </member>
        <member name="T:ExMat.ExOuterType">
            <summary>
            Outer variable types
            </summary>
        </member>
        <member name="F:ExMat.ExOuterType.LOCAL">
            <summary>
            Local var
            </summary>
        </member>
        <member name="F:ExMat.ExOuterType.OUTER">
            <summary>
            Outer val
            </summary>
        </member>
        <member name="T:ExMat.ArithmeticMask">
            <summary>
            Arithmetic operation masks
            </summary>
        </member>
        <member name="F:ExMat.ArithmeticMask.INT">
            <summary>
            Integers
            </summary>
        </member>
        <member name="F:ExMat.ArithmeticMask.INTCOMPLEX">
            <summary>
            Integer-complex
            </summary>
        </member>
        <member name="F:ExMat.ArithmeticMask.FLOAT">
            <summary>
            Floats
            </summary>
        </member>
        <member name="F:ExMat.ArithmeticMask.FLOATINT">
            <summary>
            Float-integer
            </summary>
        </member>
        <member name="F:ExMat.ArithmeticMask.FLOATCOMPLEX">
            <summary>
            Float-complex
            </summary>
        </member>
        <member name="F:ExMat.ArithmeticMask.COMPLEX">
            <summary>
            Complex numbers
            </summary>
        </member>
        <member name="F:ExMat.ArithmeticMask.STRING">
            <summary>
            Strings
            </summary>
        </member>
        <member name="F:ExMat.ArithmeticMask.STRINGINT">
            <summary>
            String-integer
            </summary>
        </member>
        <member name="F:ExMat.ArithmeticMask.STRINGFLOAT">
            <summary>
            String-float
            </summary>
        </member>
        <member name="F:ExMat.ArithmeticMask.STRINGCOMPLEX">
            <summary>
            String-complex
            </summary>
        </member>
        <member name="F:ExMat.ArithmeticMask.STRINGBOOL">
            <summary>
            String-bool
            </summary>
        </member>
        <member name="F:ExMat.ArithmeticMask.STRINGNULL">
            <summary>
            String-null
            </summary>
        </member>
        <member name="T:ExMat.ExFallback">
            <summary>
            Fallback types
            </summary>
        </member>
        <member name="F:ExMat.ExFallback.OK">
            <summary>
            Match found, no need of further search
            </summary>
        </member>
        <member name="F:ExMat.ExFallback.NOMATCH">
            <summary>
            No match found, continue search
            </summary>
        </member>
        <member name="F:ExMat.ExFallback.ERROR">
            <summary>
            Error during search
            </summary>
        </member>
        <member name="F:ExMat.ExFallback.DONT">
            <summary>
            Don't search
            </summary>
        </member>
        <member name="T:ExMat.ExProcessInfo">
            <summary>
            Internal, for safer process data getter
            </summary>
        </member>
        <member name="F:ExMat.ExProcessInfo.DATE">
            <summary>
            Start date of the process
            </summary>
        </member>
        <member name="F:ExMat.ExProcessInfo.MODULE">
            <summary>
            Main module of the process
            </summary>
        </member>
        <member name="F:ExMat.ExProcessInfo.ARGS">
            <summary>
            Start arguments of the process
            </summary>
        </member>
        <member name="T:ExMat.ExClosureType">
            <summary>
            Types of functions
            </summary>
        </member>
        <member name="F:ExMat.ExClosureType.DEFAULT">
            <summary>
            Default function type
            </summary>
        </member>
        <member name="F:ExMat.ExClosureType.RULE">
            <summary>
            Rule definition
            </summary>
        </member>
        <member name="F:ExMat.ExClosureType.CLUSTER">
            <summary>
            Cluster definition
            </summary>
        </member>
        <member name="F:ExMat.ExClosureType.SEQUENCE">
            <summary>
            Sequence definition
            </summary>
        </member>
        <member name="T:ExMat.ExFuncType">
            <summary>
            <see cref="F:ExMat.ExClosureType.DEFAULT"/> closure's function declaration type
            </summary>
        </member>
        <member name="F:ExMat.ExFuncType.DEFAULT">
            <summary>
            Default, nothing special
            </summary>
        </member>
        <member name="F:ExMat.ExFuncType.LAMBDA">
            <summary>
            Lambda function
            </summary>
        </member>
        <member name="F:ExMat.ExFuncType.CONSTRUCTOR">
            <summary>
            Class constructor method
            </summary>
        </member>
        <member name="T:ExMat.Outer.ExOuter">
            <summary>
            Internal object for outer value references
            </summary>
        </member>
        <member name="F:ExMat.Outer.ExOuter.Index">
            <summary>
            
            </summary>
        </member>
        <member name="F:ExMat.Outer.ExOuter.ValueRef">
            <summary>
            
            </summary>
        </member>
        <member name="F:ExMat.Outer.ExOuter._prev">
            <summary>
            
            </summary>
        </member>
        <member name="F:ExMat.Outer.ExOuter._next">
            <summary>
            
            </summary>
        </member>
        <member name="F:ExMat.Outer.ExOuter.SharedState">
            <summary>
            
            </summary>
        </member>
        <member name="M:ExMat.Outer.ExOuter.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ExMat.Outer.ExOuter.Create(ExMat.States.ExSState,ExMat.Objects.ExObject)">
            <summary>
            
            </summary>
            <param name="exS"></param>
            <param name="o"></param>
            <returns></returns>
        </member>
        <member name="M:ExMat.Outer.ExOuter.Release">
            <summary>
            
            </summary>
        </member>
        <member name="T:ExMat.FuncPrototype.ExPrototype">
            <summary>
            Closure prototype
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.ClosureType">
            <summary>
            Type of closure
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.Name">
            <summary>
            Name of the prototype
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.Source">
            <summary>
            Source code
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.SharedState">
            <summary>
            Shared state
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.Instructions">
            <summary>
            Instructions
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.Literals">
            <summary>
            Literals
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.Parameters">
            <summary>
            Parameters
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.DefaultParameters">
            <summary>
            Default values' indices of parameters
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.Functions">
            <summary>
            List of prototypes in a chain
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.LocalInfos">
            <summary>
            Local variable information
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.LineInfos">
            <summary>
            For tracking
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.HasVargs">
            <summary>
            Does the closure have vargs enabled ?
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.nInstr">
            <summary>
            Number of instructions
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.nLits">
            <summary>
            Number of literals
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.nParams">
            <summary>
            Number of parameters
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.nFuncs">
            <summary>
            Number of functions
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.nOuters">
            <summary>
            Number of outers
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.nLineInfos">
            <summary>
            Number of line infos
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.nLocalInfos">
            <summary>
            Number of local var infos
            </summary>
        </member>
        <member name="F:ExMat.FuncPrototype.ExPrototype.nDefaultParameters">
            <summary>
            Number of default values
            </summary>
        </member>
        <member name="M:ExMat.FuncPrototype.ExPrototype.#ctor">
            <summary>
            Initializer
            </summary>
        </member>
        <member name="M:ExMat.FuncPrototype.ExPrototype.IsFunction">
            <summary>
            Returns <see cref="F:ExMat.FuncPrototype.ExPrototype.ClosureType"/> == <see cref="F:ExMat.ExClosureType.DEFAULT"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:ExMat.FuncPrototype.ExPrototype.IsCluster">
            <summary>
            Returns <see cref="F:ExMat.FuncPrototype.ExPrototype.ClosureType"/> == <see cref="F:ExMat.ExClosureType.CLUSTER"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:ExMat.FuncPrototype.ExPrototype.IsRule">
            <summary>
            Returns <see cref="F:ExMat.FuncPrototype.ExPrototype.ClosureType"/> == <see cref="F:ExMat.ExClosureType.RULE"/>
            </summary>
            <returns></returns>
        </member>
        <member name="M:ExMat.FuncPrototype.ExPrototype.IsSequence">
            <summary>
            Returns <see cref="F:ExMat.FuncPrototype.ExPrototype.ClosureType"/> == <see cref="F:ExMat.ExClosureType.SEQUENCE"/>
            </summary>
            <returns></returns>
        </member>
        <member name="T:ExMat.Token.TokenType">
            <summary>
            Source code tokens
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.STARTERTOKEN">
            <summary>
            Internal, placeholder token to use before starting the lexer
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.UNKNOWN">
            <summary>
            Unknown token
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.ENDLINE">
            <summary>
            End of line, <see cref="F:ExMat.ExMat.EndChar"/> value
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.IDENTIFIER">
            <summary>
            Any [a-zA-Z][a-zA-Z0-9]+ pattern value
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.ASG">
            <summary>
            '=' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.INTEGER">
            <summary>
            Integer value
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.FLOAT">
            <summary>
            Float value
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.SCIENTIFIC">
            <summary>
            Float value with scientific notation
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.COMPLEX">
            <summary>
            Complex number
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.LITERAL">
            <summary>
            Characters enclosed within "" or $""
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.SPACE">
            <summary>
            <code>@(Z|R|N|C|E)[+-]?('\\d(\\*\\d)*)?@</code> pattern
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.HEX">
            <summary>
            \x{nn} or \u{nnnn} characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.BINARY">
            <summary>
            0B... or 0b... characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.ADD">
            <summary>
            '+' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.SUB">
            <summary>
            '-' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.MLT">
            <summary>
            '*' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.DIV">
            <summary>
            '/' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.MOD">
            <summary>
            '%' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.EXP">
            <summary>
            "**" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.INC">
            <summary>
            "++" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.DEC">
            <summary>
            "--" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.LSHF">
            <summary>
            "&lt;&lt;" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.RSHF">
            <summary>
            ">>" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.MATTRANSPOSE">
            <summary>
            ' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.MATMLT">
            <summary>
            ".*" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.CARTESIAN">
            <summary>
            "*.*" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.BNOT">
            <summary>
            '~' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.BAND">
            <summary>
            '&amp;' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.BOR">
            <summary>
            '|' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.BXOR">
            <summary>
            '^' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.AND">
            <summary>
            "&amp;&amp;" characters or "and" named keyword 
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.OR">
            <summary>
            "||" characters or"or" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.IN">
            <summary>
            "in" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.NOTIN">
            <summary>
            "not in" combination
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.EXC">
            <summary>
            '!' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.QMARK">
            <summary>
            '?' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.LST">
            <summary>
            '&lt;' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.GRT">
            <summary>
            '>' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.LET">
            <summary>
            "&lt;=" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.GET">
            <summary>
            ">=" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.EQU">
            <summary>
            "==" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.NEQ">
            <summary>
            "!=" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.ADDEQ">
            <summary>
            "+=" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.SUBEQ">
            <summary>
            "-=" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.MLTEQ">
            <summary>
            "*=" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.DIVEQ">
            <summary>
            "/=" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.MODEQ">
            <summary>
            "%=" characters
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.NULL">
            <summary>
            "<see cref="F:ExMat.ExMat.NullName"/>" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.TRUE">
            <summary>
            "true" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.FALSE">
            <summary>
            "false" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.IF">
            <summary>
            "if" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.ELSE">
            <summary>
            "else" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.FOR">
            <summary>
            "for" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.FOREACH">
            <summary>
            "foreach" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.CONTINUE">
            <summary>
            "continue" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.BREAK">
            <summary>
            "break" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.VAR">
            <summary>
            "var" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.CONST">
            <summary>
            "const" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.FUNCTION">
            <summary>
            "function" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.CLUSTER">
            <summary>
            "cluster" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.RULE">
            <summary>
            "rule" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.CLASS">
            <summary>
            "class" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.SEQUENCE">
            <summary>
            "seq" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.RETURN">
            <summary>
            "return" named keyword
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.DELETE">
            <summary>
            "delete" named keyword, for deleting slots
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.TYPEOF">
            <summary>
            "typeof" named keyword, for returning type name strings
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.INSTANCEOF">
            <summary>
            "instanceof" named keyword, for checking if an instance was instanced from a class
            <para><c>myInstance instanceof myClass</c></para>
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.CONSTRUCTOR">
            <summary>
            "<see cref="F:ExMat.ExMat.ConstructorName"/>" named keyword, class constructor name
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.THIS">
            <summary>
            "<see cref="F:ExMat.ExMat.ThisName"/>" named keyword, self reference
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.BASE">
            <summary>
            "<see cref="F:ExMat.ExMat.BaseName"/>" named keyword, base object/class reference
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.RELOAD">
            <summary>
            "<see cref="F:ExMat.ExMat.ReloadName"/>" named keyword, for reloading std libs
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.LAMBDA">
            <summary>
            "$(" characters, lambda functions
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.VARGS">
            <summary>
            "..." characters, variable arguments
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.DEFAULT">
            <summary>
            ".." characters, parameter's default value 
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.NEWSLOT">
            <summary>
            "&lt;>" characters, new dictionary slot or class member
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.GLOBAL">
            <summary>
            "::" characters, global reference
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.NEWLINE">
            <summary>
            '\n' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.DOT">
            <summary>
            '.' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.COL">
            <summary>
            ':' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.SEP">
            <summary>
            ',' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.SMC">
            <summary>
            ';' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.ROUNDOPEN">
            <summary>
            '(' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.ROUNDCLOSE">
            <summary>
            ')' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.CURLYOPEN">
            <summary>
            '{' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.CURLYCLOSE">
            <summary>
            '}' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.SQUAREOPEN">
            <summary>
            ']' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.SQUARECLOSE">
            <summary>
            '[' character
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.COMMENT">
            <summary>
            "//" characters for single line comment, "/*" and "*/" characters for block comment
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.ELEMENTDEF">
            <summary>
            "=>" characters, cluster output element definition
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.ATTRIBUTEBEGIN">
            <summary>
            "/." characters, class member or method attribute block start
            </summary>
        </member>
        <member name="F:ExMat.Token.TokenType.ATTRIBUTEFINISH">
            <summary>
            "./" characters, class member or method attribute block end
            </summary>
        </member>
        <member name="T:ExMat.ExTypeCheck">
            <summary>
            A class which provides basic type and flag checking methods
            </summary>
        </member>
        <member name="M:ExMat.ExTypeCheck.IsNull(ExMat.Objects.ExObject)">
            <summary>
            Return wheter given object is type of <see cref="F:ExMat.ExObjType.NULL"/>
            </summary>
            <param name="obj">Object to check</param>
            <returns></returns>
        </member>
        <member name="M:ExMat.ExTypeCheck.IsNotNull(ExMat.Objects.ExObject)">
            <summary>
            Return wheter given object is not type of <see cref="F:ExMat.ExObjType.NULL"/>
            </summary>
            <param name="obj">Object to check</param>
            <returns></returns>
        </member>
        <member name="M:ExMat.ExTypeCheck.IsDelegable(ExMat.Objects.ExObject)">
            <summary>
            Return wheter given object has delegates available
            </summary>
            <param name="obj">Object to check</param>
            <returns></returns>
        </member>
        <member name="M:ExMat.ExTypeCheck.IsRealNumber(ExMat.Objects.ExObject)">
            <summary>
            Return wheter given object is type of <see cref="F:ExMat.ExObjType.INTEGER"/> or <see cref="F:ExMat.ExObjType.FLOAT"/>
            </summary>
            <param name="obj">Object to check</param>
            <returns></returns>
        </member>
        <member name="M:ExMat.ExTypeCheck.IsNumeric(ExMat.Objects.ExObject)">
            <summary>
            Return wheter given object is type of <see cref="F:ExMat.ExObjType.COMPLEX"/>, <see cref="F:ExMat.ExObjType.INTEGER"/> or <see cref="F:ExMat.ExObjType.FLOAT"/>
            </summary>
            <param name="obj">Object to check</param>
            <returns></returns>
        </member>
        <member name="M:ExMat.ExTypeCheck.IsCountingRefs(ExMat.Objects.ExObject)">
            <summary>
            Return wheter given object is counting references made
            </summary>
            <param name="obj">Object to check</param>
            <returns></returns>
        </member>
        <member name="M:ExMat.ExTypeCheck.DoesTypeCountRef(ExMat.ExObjType)">
            <summary>
            Return wheter given type allow counting references
            </summary>
            <param name="t">Type to check</param>
            <returns></returns>
        </member>
        <member name="M:ExMat.ExTypeCheck.IsFalseable(ExMat.Objects.ExObject)">
            <summary>
            Return wheter given object can ever be counted as <see langword="false"/> boolean value
            </summary>
            <param name="obj">Object to check</param>
            <returns></returns>
        </member>
        <member name="T:ExMat.Utils.ExUtils">
            <summary>
            Utility method provider
            </summary>
        </member>
        <member name="M:ExMat.Utils.ExUtils.GetOrderedNumericList(System.Collections.Generic.List{ExMat.Objects.ExObject})">
            <summary>
            Return ordered list of real number found in given list
            </summary>
            <param name="lis">List to iterate through</param>
            <returns>A new list with real numbers found in <paramref name="lis"/> in ascending order</returns>
        </member>
        <member name="M:ExMat.Utils.ExUtils.AssertNumericArray(ExMat.Objects.ExObject)">
            <summary>
            Return wheter lis has only numeric values
            </summary>
            <param name="lis">List to check</param>
            <returns></returns>
        </member>
        <member name="M:ExMat.Utils.ExUtils.LongTo32NonNegativeIntegerRange(System.Int64)">
            <summary>
            Get a value between [0,<see cref="F:System.Int32.MaxValue"/>] from given 64bit integer
            </summary>
            <param name="i">Value to put within limits</param>
            <returns>if <c><paramref name="i"/> &gt; 0</c> then if <c><paramref name="i"/> &gt; <see cref="F:System.Int32.MaxValue"/> -> <see cref="F:System.Int32.MaxValue"/></c> else <c><paramref name="i"/></c>
            <para>if <c><paramref name="i"/> &lt; 0</c> then if <c><paramref name="i"/> &gt; <see cref="F:System.Int32.MinValue"/> -> -<paramref name="i"/></c> else <c>0</c></para></returns>
        </member>
        <member name="M:ExMat.Utils.ExUtils.LongTo32SignedIntegerRange(System.Int64)">
            <summary>
            Get a value between [<see cref="F:System.Int32.MinValue"/>,<see cref="F:System.Int32.MaxValue"/>] from given 64bit integer
            </summary>
            <param name="i">Value to put within limits</param>
            <returns></returns>
        </member>
        <member name="M:ExMat.Utils.ExUtils.AppendFillerNTimes(System.Collections.Generic.List{ExMat.Objects.ExObject},ExMat.Objects.ExObject,System.Int32)">
            <summary>
            Append given filler object to given list given times
            </summary>
            <param name="list">List to append to</param>
            <param name="filler">Filler object, <see langword="null"/> for <see cref="F:ExMat.ExObjType.NULL"/> fillers</param>
            <param name="n">How many times to append</param>
            <returns><paramref name="list"/> list</returns>
        </member>
        <member name="M:ExMat.Utils.ExUtils.ShuffleList(System.Collections.Generic.List{ExMat.Objects.ExObject})">
            <summary>
            Create a new shuffled list from given list
            </summary>
            <param name="list">List to get elements from</param>
            <returns>A new list</returns>
        </member>
        <member name="M:ExMat.Utils.ExUtils.GetACopyOf(System.Collections.Generic.List{ExMat.Objects.ExObject})">
            <summary>
            Get a copy of the given list
            </summary>
            <param name="list">List to copy</param>
            <returns>A new list, copy of <paramref name="list"/></returns>
        </member>
        <member name="M:ExMat.Utils.ExUtils.GetNRandomObjectsFrom(System.Collections.Generic.List{ExMat.Objects.ExObject},System.Int32)">
            <summary>
            Get given amount of random distinct(same index won't be picked again) values from given list.
            </summary>
            <param name="list">List to pick values from</param>
            <param name="n">Amount of items to pick</param>
            <returns>A new list with <paramref name="n"/> distinct items picked from <paramref name="list"/></returns>
        </member>
        <member name="M:ExMat.Utils.ExUtils.InitList``1(System.Collections.Generic.List{``0}@,System.Int32)">
            <summary>
            Initialize given list object with null objects
            </summary>
            <typeparam name="T">Class with empty constructor</typeparam>
            <param name="lis">List to initialize</param>
            <param name="n">Length of the list</param>
        </member>
        <member name="M:ExMat.Utils.ExUtils.InitList(System.Collections.Generic.List{ExMat.Objects.ExObject}@,System.Int32,ExMat.Objects.ExObject)">
            <summary>
            Initialize given list object filled with given filler objects
            </summary>
            <param name="lis">List to initialize</param>
            <param name="n">Length of the list</param>
            <param name="filler">Filler object</param>
        </member>
        <member name="M:ExMat.Utils.ExUtils.ExpandListTo``1(System.Collections.Generic.List{``0},System.Int32)">
            <summary>
            Expand list with <typeparamref name="T"/> values to have the new given length
            </summary>
            <typeparam name="T">Class with empty constructor</typeparam>
            <param name="lis"></param>
            <param name="n"></param>
        </member>
        <member name="T:ExMat.VM.ExVM">
            <summary>
            A virtual machine model to execute instructions which use <see cref="T:ExMat.OPs.ExOperationCode"/>
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.StartingTime">
            <summary>
            Time when the virtual machine was first initialized
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.StartDirectory">
            <summary>
            Stores the starting directory
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.SharedState">
            <summary>
            Shared state used across objects
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.Stack">
            <summary>
            Virtual memory stack to do push and pop operations with objects
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.StackSize">
            <summary>
            Virtual memory size
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.StackBase">
            <summary>
            Virtual memory stack's base index used by the current scope
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.StackTop">
            <summary>
            Virtual memory stack's top index used by the current scope
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.CallStack">
            <summary>
            Call stack for scoped instructions
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.CallInfo">
            <summary>
            Call stack as linked list
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.AllocatedCallSize">
            <summary>
            Allocated initial size for call stack
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.CallStackSize">
            <summary>
            Current size of call stack
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.RootDictionary">
            <summary>
            Global(root) dictionary
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.TempRegistery">
            <summary>
            Temporary value
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.Outers">
            <summary>
            Outer variable information
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.ErrorString">
            <summary>
            Error message
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.ErrorTrace">
            <summary>
            Error traces
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.ErrorOverride">
            <summary>
            Error type override from external interrupts
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.ForceThrow">
            <summary>
            Wheter to force raise error after execution
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.nNativeCalls">
            <summary>
            Native call counter
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.nMetaCalls">
            <summary>
            Meta call counter
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.GotUserInput">
            <summary>
            User using input functions?
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.PrintedToConsole">
            <summary>
            Has anything been printed?
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.IsMainCall">
            <summary>
            Is current call the root call?
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.IsInteractive">
            <summary>
            Is this VM activated in an interactive console?
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.InputCount">
            <summary>
            Input count for interactive console
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.ExitCalled">
            <summary>
            Must exit at the end of current call stack frame
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.ExitCode">
            <summary>
            Exit return value
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM._forcereturn">
            <summary>
            Temporary storage for the state of force returning
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.ActiveThread">
            <summary>
            VM's thread
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.IsSleeping">
            <summary>
            Is VM thread currently sleeping?
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.Flags">
            <summary>
            Interactive console flags using <see cref="T:ExMat.ExInteractiveConsoleFlag"/>
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.Printer">
            <summary>
            Printer method
            </summary>
        </member>
        <member name="P:ExMat.VM.ExVM.HasPrinter">
            <summary>
            Wheter <see cref="F:ExMat.VM.ExVM.Printer"/> is not null
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.LineReader">
            <summary>
            Line reader method
            </summary>
        </member>
        <member name="P:ExMat.VM.ExVM.HasLineReader">
            <summary>
            Wheter <see cref="F:ExMat.VM.ExVM.LineReader"/> is not null
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.KeyReader">
            <summary>
            Key reader method
            </summary>
        </member>
        <member name="P:ExMat.VM.ExVM.HasKeyReader">
            <summary>
            Wheter <see cref="F:ExMat.VM.ExVM.KeyReader"/> is not null
            </summary>
        </member>
        <member name="F:ExMat.VM.ExVM.IntKeyReader">
            <summary>
            Key reader method
            </summary>
        </member>
        <member name="P:ExMat.VM.ExVM.HasIntKeyReader">
            <summary>
            Wheter <see cref="F:ExMat.VM.ExVM.IntKeyReader"/> is not null
            </summary>
        </member>
        <member name="M:ExMat.VM.ExVM.Print(System.String)">
            <summary>
            Print given string without new-line at the end
            </summary>
            <param name="str">Message to print</param>
        </member>
        <member name="M:ExMat.VM.ExVM.PrintLine(System.String)">
            <summary>
            Print given string with new-line at the end
            </summary>
            <param name="str">Message to print</param>
        </member>
        <member name="M:ExMat.VM.ExVM.AddToErrorMessage(System.String)">
            <summary>
            Add message to current error messages
            </summary>
            <param name="msg">Error message</param>
            <returns>Always returns <see cref="F:ExMat.ExFunctionStatus.ERROR"/> to make the code more compact</returns>
        </member>
        <member name="M:ExMat.VM.ExVM.AddToErrorMessage(System.String,System.Object[])">
            <summary>
            Add new error messages
            </summary>
            <param name="format">Format string</param>
            <param name="msgs">Objects to replace in <paramref name="format"/></param>
            <returns>Always returns <see cref="F:ExMat.ExFunctionStatus.ERROR"/></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.Throw(System.String,ExMat.VM.ExVM,ExMat.Exceptions.ExExceptionType)">
            <summary>
            Throws an exception with given message and type
            </summary>
            <param name="msg">Message</param>
            <param name="vm">VM to report with</param>
            <param name="type">Exception type</param>
        </member>
        <member name="M:ExMat.VM.ExVM.HasFlag(ExMat.ExInteractiveConsoleFlag)">
            <summary>
            Checks if interactive console has the given flag
            </summary>
            <param name="flag">Flag to check</param>
        </member>
        <member name="M:ExMat.VM.ExVM.SetFlag(ExMat.ExInteractiveConsoleFlag)">
            <summary>
            Sets given interactive console flag
            </summary>
            <param name="flag">Flag to set</param>
        </member>
        <member name="M:ExMat.VM.ExVM.RemoveFlag(ExMat.ExInteractiveConsoleFlag)">
            <summary>
            Removes given interactive console flag
            </summary>
            <param name="flag">Flag to remove</param>
        </member>
        <member name="M:ExMat.VM.ExVM.ToggleFlag(ExMat.ExInteractiveConsoleFlag)">
            <summary>
            Toggles given interactive console flag
            </summary>
            <param name="flag">Flag to switch/toggle</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Initialize(System.Int32)">
            <summary>
            Initialize the stacks 
            </summary>
            <param name="stacksize">Virtual stack size</param>
        </member>
        <member name="M:ExMat.VM.ExVM.FillArgumentArray(System.Collections.Generic.List{ExMat.Objects.ExObject},System.Int32)">
            <summary>
            Get <paramref name="nargs"/> values from the top of the stack and return them in a list
            </summary>
            <param name="args">List to put values in</param>
            <param name="nargs">Amount of arguments</param>
        </member>
        <member name="M:ExMat.VM.ExVM.GetSimpleString(ExMat.Objects.ExObject)">
            <summary>
            Similar to <see cref="M:ExMat.API.ExApi.GetSimpleString(ExMat.Objects.ExObject)"/>, but uses _STRING meta method for instances
            </summary>
            <param name="obj">Object to stringify</param>
            <returns>Stringified value of <paramref name="obj"/></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.ToString(ExMat.Objects.ExObject,ExMat.Objects.ExObject@,System.Int32,System.Boolean,System.Boolean,System.String,System.Int32)">
            <summary>
            Stringify given object
            </summary>
            <param name="obj">Object to use</param>
            <param name="res">Resulting string object</param>
            <param name="maxdepth">Maximum printing depth for lists and dictionaries</param>
            <param name="dval">Is in a dictionary</param>
            <param name="beauty">Use better indentation</param>
            <param name="prefix">Prefix for each element of lists and dictionaries</param>
            <param name="currentdepth">Current printing depth</param>
            <returns>Wheter the process has succeeded</returns>
        </member>
        <member name="M:ExMat.VM.ExVM.Pop(System.Int64)">
            <summary>
            Pop given amount of values from the top of the stack
            </summary>
            <param name="n">Amount of objects to pop</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Pop(System.Int32)">
            <summary>
            Pop given amount of values from the top of the stack
            </summary>
            <param name="n">Amount of objects to pop</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Pop">
            <summary>
            Pop the object on top of the stack
            </summary>
        </member>
        <member name="M:ExMat.VM.ExVM.CleanReturn(System.Int64,System.Numerics.Complex)">
            <summary>
            Pop <paramref name="n"/> objects from the top of the stack and push <paramref name="o"/> on top
            </summary>
            <param name="n">Amount of objects to pop</param>
            <param name="o">Object to push after pops</param>
            <returns>Always returns <see cref="F:ExMat.ExFunctionStatus.SUCCESS"/></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.CleanReturn(System.Int64,System.String)">
            <summary>
            Pop <paramref name="n"/> objects from the top of the stack and push <paramref name="o"/> on top
            </summary>
            <param name="n">Amount of objects to pop</param>
            <param name="o">Object to push after pops</param>
            <returns>Always returns <see cref="F:ExMat.ExFunctionStatus.SUCCESS"/></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.CleanReturn(System.Int64,System.Double)">
            <summary>
            Pop <paramref name="n"/> objects from the top of the stack and push <paramref name="o"/> on top
            </summary>
            <param name="n">Amount of objects to pop</param>
            <param name="o">Object to push after pops</param>
            <returns>Always returns <see cref="F:ExMat.ExFunctionStatus.SUCCESS"/></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.CleanReturn(System.Int64,System.Int64)">
            <summary>
            Pop <paramref name="n"/> objects from the top of the stack and push <paramref name="o"/> on top
            </summary>
            <param name="n">Amount of objects to pop</param>
            <param name="o">Object to push after pops</param>
            <returns>Always returns <see cref="F:ExMat.ExFunctionStatus.SUCCESS"/></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.CleanReturn(System.Int64,System.Boolean)">
            <summary>
            Pop <paramref name="n"/> objects from the top of the stack and push <paramref name="o"/> on top
            </summary>
            <param name="n">Amount of objects to pop</param>
            <param name="o">Object to push after pops</param>
            <returns>Always returns <see cref="F:ExMat.ExFunctionStatus.SUCCESS"/></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.CleanReturn(System.Int64,System.String[])">
            <summary>
            Pop <paramref name="n"/> objects from the top of the stack and push <paramref name="o"/> on top
            </summary>
            <param name="n">Amount of objects to pop</param>
            <param name="o">Object to push after pops</param>
            <returns>Always returns <see cref="F:ExMat.ExFunctionStatus.SUCCESS"/></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.CleanReturn(System.Int64,System.Collections.Generic.List{ExMat.Objects.ExObject})">
            <summary>
            Pop <paramref name="n"/> objects from the top of the stack and push <paramref name="o"/> on top
            </summary>
            <param name="n">Amount of objects to pop</param>
            <param name="o">Object to push after pops</param>
            <returns>Always returns <see cref="F:ExMat.ExFunctionStatus.SUCCESS"/></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.CleanReturn(System.Int64,System.Collections.Generic.Dictionary{System.String,ExMat.Objects.ExObject})">
            <summary>
            Pop <paramref name="n"/> objects from the top of the stack and push <paramref name="o"/> on top
            </summary>
            <param name="n">Amount of objects to pop</param>
            <param name="o">Object to push after pops</param>
            <returns>Always returns <see cref="F:ExMat.ExFunctionStatus.SUCCESS"/></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.CleanReturn``1(System.Int64,``0)">
            <summary>
            Pop <paramref name="n"/> objects from the top of the stack and push <paramref name="o"/> on top
            </summary>
            <typeparam name="T"><see cref="T:ExMat.Objects.ExObject"/> type</typeparam>
            <param name="n">Amount of objects to pop</param>
            <param name="o">Object to push after pops</param>
            <returns>Always returns <see cref="F:ExMat.ExFunctionStatus.SUCCESS"/></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.PushParse(System.Collections.Generic.List{ExMat.Objects.ExObject})">
            <summary>
            Push a list of object to the stack
            </summary>
            <param name="o">List of objects to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(System.String)">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(System.Numerics.Complex)">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(System.Int32)">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(System.Int64)">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(System.Double)">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(System.Boolean)">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(ExMat.Objects.ExObject)">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(System.Collections.Generic.Dictionary{System.String,ExMat.Objects.ExObject})">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(System.Collections.Generic.List{ExMat.Objects.ExObject})">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(System.String[])">
            <summary>
            Push given string array as a single list of objects on top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(ExMat.ExClass.ExInstance)">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(ExMat.ExClass.ExClass)">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(ExMat.Closure.ExClosure)">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(ExMat.Closure.ExNativeClosure)">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(ExMat.Outer.ExOuter)">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(ExMat.Objects.ExWeakRef)">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.Push(ExMat.FuncPrototype.ExPrototype)">
            <summary>
            Push given object to the top of the stack
            </summary>
            <param name="o">Object to push</param>
        </member>
        <member name="M:ExMat.VM.ExVM.PushNull">
            <summary>
            Nullify the top of the stack and increment the top index
            </summary>
        </member>
        <member name="M:ExMat.VM.ExVM.Top">
            <summary>
            Get the object on top of the stack
            </summary>
            <returns>Returns <c><see cref="F:ExMat.VM.ExVM.Stack"/>[<see cref="F:ExMat.VM.ExVM.StackTop"/> - 1]</c></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.GetAbove(System.Int32)">
            <summary>
            Get the <paramref name="n"/>th object from the top of the stack
            </summary>
            <param name="n">Indexes below stack top index, -1 for the top object</param>
            <returns>Returns <c><see cref="F:ExMat.VM.ExVM.Stack"/>[<see cref="F:ExMat.VM.ExVM.StackTop"/> + n]</c></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.GetAt(System.Int32)">
            <summary>
            Get the object in the given index from the stack
            </summary>
            <param name="n">Stack index</param>
            <returns>Returns <c><see cref="F:ExMat.VM.ExVM.Stack"/>[n]</c></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.GetArgument(System.Int32)">
            <summary>
            Get the <paramref name="idx"/>th argument passed to a native function
            </summary>
            <param name="idx">Argument index >= 1</param>
            <returns>Returns <c><see cref="F:ExMat.VM.ExVM.Stack"/>[<see cref="F:ExMat.VM.ExVM.StackBase"/> + <paramref name="idx"/>]</c></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.GetRootArgument">
            <summary>
            Get the root object from current native function call, this will be the root dictionary for non-deleagets and the delegate base object for delegate functions
            </summary>
            <returns>Returns <c><see cref="F:ExMat.VM.ExVM.Stack"/>[<see cref="F:ExMat.VM.ExVM.StackBase"/>]</c></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.GetRootClosure">
            <summary>
            Get the native closure object which was used for the closure call
            </summary>
            <returns>Returns <c><see cref="F:ExMat.VM.ExVM.Stack"/>[<see cref="F:ExMat.VM.ExVM.StackBase"/> - 1]</c> object's <see cref="M:ExMat.Objects.ExObject.GetNClosure"/></returns>
        </member>
        <member name="M:ExMat.VM.ExVM.GetPositiveIntegerArgument(System.Int32,System.Int64)">
            <summary>
            Get argument at given index and force it to be positive or given default value
            </summary>
            <param name="idx">Argument no</param>
            <param name="defaultVal">Default value to use for negative values</param>
            <returns>Positive integer</returns>
        </member>
        <member name="M:ExMat.VM.ExVM.GetPositiveRangedIntegerArgument(System.Int32,System.Int64,System.Int64)">
            <summary>
            Get argument at given index and force it to be in range [<paramref name="min"/>, <paramref name="max"/>]
            </summary>
            <param name="idx">Argument no</param>
            <param name="min">Minimum value inclusive</param>
            <param name="max">Maximum value inclusive</param>
            <returns>An integer in range [<paramref name="min"/>, <paramref name="max"/>]</returns>
        </member>
        <member name="M:ExMat.VM.ExVM.DoNegateOP(ExMat.Objects.ExObject,ExMat.Objects.ExObject)">
            <summary>
            Assign the negated result of given value to given target
            </summary>
            <param name="target">Negated result</param>
            <param name="val">Value to negate</param>
            <returns>Wheter the process was successful</returns>
        </member>
        <member name="M:ExMat.VM.ExVM.InnerDoCompareOP(ExMat.Objects.ExObject,ExMat.Objects.ExObject,System.Int32@)">
            <summary>
            Compare two objects, <paramref name="t"/> will be:
            <para>-1 if <c>a &lt; b</c></para>
            <para>0 if <c>a == b</c></para>
            <para>1 if <c>a &gt; b</c></para>
            </summary>
            <param name="a">LHS object</param>
            <param name="b">RHS object</param>
            <param name="t">Result of comparison</param>
            <returns>Wheter comparison was successful, ignore <paramref name="t"/> if <see langword="false"/> is returned</returns>
        </member>
        <member name="M:ExMat.VM.ExVM.DoBitwiseOP(System.Int64,ExMat.Objects.ExObject,ExMat.Objects.ExObject,ExMat.Objects.ExObject)">
            <summary>
            Bitwise operation between two objects
            </summary>
            <param name="iop"><see cref="T:ExMat.OPs.BitOP"/> operation integer value</param>
            <param name="a">LHS value</param>
            <param name="b">RHS value</param>
            <param name="res">Result</param>
            <returns>Wheter operation was successful</returns>
        </member>
        <member name="M:ExMat.VM.ExVM.InnerDoArithmeticOPInt(ExMat.OPs.ExOperationCode,System.Int64,System.Int64,ExMat.Objects.ExObject@)">
            <summary>
            Arithmetic operation between integers
            </summary>
            <param name="op">Operation</param>
            <param name="a">LHS value</param>
            <param name="b">RHS value</param>
            <param name="res">Result</param>
            <returns>Wheter process succeeded</returns>
        </member>
        <member name="M:ExMat.VM.ExVM.InnerDoArithmeticOPFloat(ExMat.OPs.ExOperationCode,System.Double,System.Double,ExMat.Objects.ExObject@)">
            <summary>
            Arithmetic operation between floats
            </summary>
            <param name="op">Operation</param>
            <param name="a">LHS value</param>
            <param name="b">RHS value</param>
            <param name="res">Result</param>
            <returns>Wheter process succeeded</returns>
        </member>
        <member name="M:ExMat.VM.ExVM.InnerDoArithmeticOPComplex(ExMat.OPs.ExOperationCode,System.Numerics.Complex,System.Numerics.Complex,ExMat.Objects.ExObject@)">
            <summary>
            Arithmetic operation between complex numbers
            </summary>
            <param name="op">Operation</param>
            <param name="a">LHS value</param>
            <param name="b">RHS value</param>
            <param name="res">Result</param>
            <returns>Wheter process succeeded</returns>
        </member>
        <member name="M:ExMat.VM.ExVM.DoArithmeticOP(ExMat.OPs.ExOperationCode,ExMat.Objects.ExObject,ExMat.Objects.ExObject,ExMat.Objects.ExObject@)">
            <summary>
            Arithmetic operation between two objects
            </summary>
            <param name="op">Operation</param>
            <param name="a">LHS value</param>
            <param name="b">RHS value</param>
            <param name="res">Result</param>
            <returns>Wheter process succeeded</returns>
        </member>
        <member name="M:ExMat.VM.ExVM.Call(ExMat.Objects.ExObject@,System.Int32,System.Int32,ExMat.Objects.ExObject@,System.Boolean)">
            <summary>
            Attempt to call given object with the given call information
            </summary>
            <param name="cls">Object to call</param>
            <param name="nArguments">Amount of arguments in the stack</param>
            <param name="stackBase">Stack base</param>
            <param name="result">Result of the call</param>
            <param name="forcereturn">Wheter to force return last value if nothings is returned</param>
            <returns>Wheter call succeded</returns>
        </member>
        <member name="M:ExMat.VM.ExVM.Dispose">
            <summary>
            Disposer
            </summary>
        </member>
        <member name="T:ExMat.Interfaces.IExClosure">
            <summary>
            Interface for closures
            </summary>
        </member>
        <member name="M:ExMat.Interfaces.IExClosure.GetAttribute(System.String)">
            <summary>
            Return information about the function meta
            </summary>
            <param name="attr">Meta attribute name</param>
            <returns>Integer(param count, def param count, min required args)
            <para>String(function name, description, return info)</para>
            <para>Bool(has vargs, is delegate)</para>
            <para>Dictionary&lt;string, ExObject>(default param values)</para>
            <para>variable(if delegate found)</para>
            <para>null(if nothing found)</para></returns>
        </member>
    </members>
</doc>
