
rule Positive(x) x > 0

rule NonZero(x) x != 0

rule Negative(x) x < 0

seq Factorial(0:1.0, 1:1.0) n * Factorial(n-1)

// Add results of given function using range(m,n+1)
function SumOf(func,m=0,n=0)
{
    ::assert(type(func) == "CLOSURE", "expected function as first argument")

    var pcount = func.n_params;

    var total = 0;

    if(pcount == 0)
    {
        for(var i = m; i <= n ; i++)
        {
            total += func()
        }
    }
    else if(pcount == 1)
    {
        for(var i = m; i <= n ; i++)
        {
            total += func(i)
        }
    }
    else if(pcount == 2)
    {
        for(var i = m; i <= n ; i++)
        {
            total += func(i,m)
        }
    }
    else
    {
        ::assert(func.n_minargs <= 3,"given function require at least "+func.n_minargs+" arguments")

        for(var i = m; i <= n ; i++)
        {
            total += func(i,m,n)
        }
    }
    return total;
}

// Multiply results of given function using range(m,n+1)
function MulOf(func,m=0,n=0)
{
    ::assert(type(func) == "CLOSURE", "expected function as first argument")

    var pcount = func.n_params;

    var total = 1;

    if(pcount == 0)
    {
        for(var i = m; i <= n ; i++)
        {
            total *= func()
        }
    }
    else if(pcount == 1)
    {
        for(var i = m; i <= n ; i++)
        {
            total *= func(i)
        }
    }
    else if(pcount == 2)
    {
        for(var i = m; i <= n ; i++)
        {
            total *= func(i,m)
        }
    }
    else
    {
        ::assert(func.n_minargs <= 3,"given function require at least "+func.n_minargs+" arguments")

        for(var i = m; i <= n ; i++)
        {
            total *= func(i,m,n)
        }
    }
    return total;
}

class Vector3D
{
    init(_x=0,_y=0,_z=0)
    {
        ::assert(type(_x) in NumericTypes, "expected numeric value for 'x' of 'Vector3D'")
        ::assert(type(_y) in NumericTypes, "expected numeric value for 'y' of 'Vector3D'")
        ::assert(type(_z) in NumericTypes, "expected numeric value for 'z' of 'Vector3D'")
        this.x = _x;
        this.y = _y;
        this.z = _z;
    }
    
    /. 
        is_coordinate = true 
    ./
    x = 0;

    /. 
        is_coordinate = true 
    ./
    y = 0;

    /. 
        is_coordinate = true 
    ./
    z = 0;

    /. 
        is_coordinate = false 
    ./
    NumericTypes = ["INTEGER", "FLOAT"]

    function Length()
    {
        return (this.x**2 + this.y**2 + this.z**2)**0.5
    }

    function Scale(scale)
    {
        ::assert(type(scale) in NumericTypes, "expected numeric value for 'Scale' of 'Vector3D'")

        return Vector3D(this.x * scale, this.y * scale, this.z * scale);;
    }

    // Meta methods
    function _ADD(vec)
    {
        ::assert(vec instanceof Vector3D, "expected 'Vector3D' type for '+' of 'Vector3D'")

        return Vector3D(this.x + vec.x, this.y + vec.y, this.z + vec.z);
    }

    function _SUB(vec)
    {
        ::assert(vec instanceof Vector3D, "expected 'Vector3D' type for '-' of 'Vector3D'")

        return Vector3D(this.x + vec.x, this.y + vec.y, this.z + vec.z);
    }

    function _MLT(vec)
    {
        ::assert(vec instanceof Vector3D, "expected 'Vector3D' type for '*' of 'Vector3D'")

        return Vector3D(this.x * vec.x, this.y * vec.y, this.z * vec.z);
    }

    function _DIV(vec)
    {
        ::assert(vec instanceof Vector3D, "expected 'Vector3D' type for '/' of 'Vector3D'")

        return Vector3D(this.x / vec.x, this.y / vec.y, this.z / vec.z);
    }

    function _MOD(vec)
    {
        ::assert(vec instanceof Vector3D, "expected 'Vector3D' type for '%' of 'Vector3D'")

        return Vector3D(this.x % vec.x, this.y % vec.y, this.z % vec.z);
    }

    function _EXP(vec)
    {
        ::assert(vec instanceof Vector3D, "expected 'Vector3D' type for '%' of 'Vector3D'")

        return Vector3D(this.x ** vec.x, this.y ** vec.y, this.z ** vec.z);
    }

    function _STRING()
    {
        return "Vector3D("+this.x+", "+this.y+", "+this.z+")";
    }
    //

    function Dot(vec)
    {
        ::assert(vec instanceof Vector3D, "expected 'Vector3D' type for 'Dot' of 'Vector3D'")

        return (this.x * vec.x + this.y * vec.y + this.z * vec.z);
    }

    function Cross(vec)
    {
        ::assert(vec instanceof Vector3D, "expected 'Vector3D' type for 'Cross' of 'Vector3D'")

        return Vector3D(this.y * vec.z - this.z * vec.y, this.z * vec.x - this.x * vec.z, this.x * vec.y - this.y * vec.x);
    }

    function AngleBetween(vec)
    {
        ::assert(vec instanceof Vector3D, "expected 'Vector3D' type for 'AngleBetween' of 'Vector3D'")

        return acos( this.Dot(vec) / ( this.Length() * vec.Length() ) );
    }
}

function Identity(n)    return matrix(n,n,$(i,j) i == j ? 1 : 0)

function RandIMat(x,y,m=0,n=2)    return matrix(x,y,$(i,j) rand(m,n))

function RandFMat(x,y,m=0,n=1)    return matrix(x,y,$(i,j) randf(m,n))    

function Combination(n, r)  return Factorial(n) / (Factorial(r) * Factorial(n-r))

function Permutation(n, r)  return Factorial(n) / Factorial(n-r)
